import {
    type PageAnnotations,
    type UINode,
    type UINodeValue,
    type Location,
    UI_NODE_TYPE_GENERIC_ACTIONS
} from '../types';
import { isTooComplex } from '../../annotations';

// terms of special parent child relations generated by specification
// (parent child relations in specification which are not found in anno libs ui nodes)
const SPECIAL_CHILD_NODES: Map<string, Set<string>> = new Map();
SPECIAL_CHILD_NODES.set(
    'com.sap.vocabularies.UI.v1.HeaderInfo',
    new Set(['com.sap.vocabularies.UI.v1.HeaderFacets', 'com.sap.vocabularies.UI.v1.Identification'])
);
const GENERIC_ACTION_TERMS = ['com.sap.vocabularies.UI.v1.DeleteHidden', 'com.sap.vocabularies.UI.v1.UpdateHidden'];
const stripTarget = (annotationPath: string | undefined): string => (annotationPath || '').split('/@').pop() || '';

/**
 * Retrieves a `UINode` from the given annotations by its hierarchical node ID.
 *
 * @param annotations The annotations object containing nodes.
 * @param id The hierarchical node ID to search for.
 * @returns The matching `UINode` if found, otherwise `undefined`.
 */
export function getAnnotationNodeById(annotations: PageAnnotations, id: number[]): UINode | undefined {
    let node: UINode | undefined = annotations.nodes.find((node) => node?.nodeId && node.nodeId[0] === id[0]);
    for (let i = 1; i < id.length; i++) {
        if (node && isTooComplex(node)) {
            return node;
        }
        node = node?.subnodes.find((node) => node.nodeId[i] === id[i]);
    }
    return node as UINode;
}

/**
 * Returns all locations for the given node.
 *
 * @param node
 * @returns
 */
export function getNodeLocations(node: UINode): Location[] {
    if (isTooComplex(node)) {
        return node.tooComplexLocations ?? [];
    }
    if (node.location) {
        return [node.location];
    }
    return [];
}

/**
 * Finds a `UINode` within a tree of nodes that matches the given annotation path.
 *
 * @param annotationPath - The annotation path to match.
 * @param nodes - The list of nodes to search within.
 * @param shallow - If true, only searches the top-level nodes.
 * @param lookUpIndex - Optional index hint to optimize search order.
 * @returns The matching node if found, otherwise `undefined`.
 */
export function nodeMatcher(
    annotationPath: string,
    nodes: UINode[],
    shallow?: boolean,
    lookUpIndex?: number
): UINode | undefined {
    const indexes = getNodeMatcherIndexes(nodes, lookUpIndex);
    for (const index of indexes) {
        const element = nodes[index];
        const adjustedAnnotationPath = element.annotationPath
            .split('/')
            .map((segment, i) => (i === 1 ? (segment.split('.').slice(-1)[0] ?? segment) : segment))
            .join('/');
        if (annotationPath === element.annotationPath || annotationPath === adjustedAnnotationPath) {
            return element;
        } else if (!shallow && !isTooComplex(element) && element.subnodes.length > 0) {
            const result = nodeMatcher(annotationPath, element.subnodes, undefined, lookUpIndex);
            if (result) {
                return result;
            }
        }
    }
}

/**
 * Method finds matching node using passed schema annotation path and tree object nested nodes and full nodes.
 *
 * @param schemaAnnotationPath Annotation path from schema to look up in annotation nodes.
 * @param annotationNodes Full annotation nodes tree.
 * @param childAnnotationNodes Current level's annotation nodes - mainly nested nodes are used to look up, but there is special cases when nodes are not on same level as schema.
 * @param nodeAnnotationPath Current annotation node path.
 * @param index Node index to look.
 * @returns Matching annotation node.
 */
export function getMatchingNode(
    schemaAnnotationPath: string,
    annotationNodes: UINode[],
    childAnnotationNodes: UINode[],
    nodeAnnotationPath?: string,
    index?: number
): UINode | undefined {
    const schemaAnnotationPathTerm = stripTarget(schemaAnnotationPath);

    let matchedNode = nodeMatcher(schemaAnnotationPath, childAnnotationNodes, undefined, index);

    // Special matching of generic action nodes
    if (!matchedNode && GENERIC_ACTION_TERMS.includes(schemaAnnotationPathTerm)) {
        const genericActionsNode = annotationNodes.find(
            (node) => (node as UINodeValue).nodeType === UI_NODE_TYPE_GENERIC_ACTIONS
        );
        matchedNode = (genericActionsNode as UINodeValue)?.subnodes.find(
            (node) => node.annotationPath === schemaAnnotationPath
        );
    }

    if (!matchedNode && SPECIAL_CHILD_NODES.get(stripTarget(nodeAnnotationPath))?.has(schemaAnnotationPathTerm)) {
        matchedNode = nodeMatcher(schemaAnnotationPath, annotationNodes, true, index);
    }

    return matchedNode;
}

/**
 * Method prepares array with indexes to loop through.
 * If index is passed as param, then we need place it first.
 * It is used for cases when nodes can have same path, but different order indexes.
 *
 * @param nodes Nodes to loop.
 * @param index Index to place as very first.
 * @returns Array of index to loop.
 */
function getNodeMatcherIndexes(nodes: UINode[], index?: number): number[] {
    const indexes: number[] = [];
    if (index !== undefined && nodes.length > index) {
        // Place passed index as first
        indexes.push(index);
    }
    for (let i = 0; i < nodes.length; i++) {
        if (i !== index) {
            indexes.push(i);
        }
    }
    return indexes;
}
