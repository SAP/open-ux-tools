import fs from 'fs';
import { basename, join, dirname } from 'path';
import { diffJson, diffTrimmedLines } from 'diff';
import type { Change } from 'diff';
import { green, red } from 'chalk';
import { AssertionValueFunctionContext, AssertionValueFunctionResult } from 'promptfoo';
import { FOLDER_PATHS } from '../types';

interface SnapshotData {
    content: {
        snapshot: string;
        source: string;
    };
    created: boolean;
}

interface SnapshotSegmentConfig {
    path: Array<string>;
    mode: string;
}

interface SnapshotConfiguration {
    snapshot: string;
    file: string;
    segments?: SnapshotSegmentConfig[];
}

/**
 * Compares the current test output against a stored snapshot to verify consistency.
 * Loads the snapshot data based on the provided test context and configuration,
 * validates it against the expected snapshot, and returns an assertion result.
 *
 * @param _output The string output generated by the test or process under validation.
 * @param context The assertion context, containing test variables and optional configuration.
 * @returns Result of assertion for promptfoo.
 */
export function validate(_output: string, context: AssertionValueFunctionContext): AssertionValueFunctionResult {
    let reason = 'Unknown';
    let pass = false;
    const projectPath = getProjectPath(context.vars);
    const config = context.config ? getConfiguration(context.config) : undefined;
    if (projectPath && config) {
        try {
            const snapshotData = getSnapshotData(projectPath, config.snapshot, config.file);
            const compareResult = validateSnapshot(snapshotData, config);
            pass = !compareResult;
            if (!pass) {
                console.log(`Snapshot mismatch for ${config.file}:\n${compareResult}`);
            }
            reason = pass ? 'Snapshot file matches' : `Snapshot file does not match: ${compareResult}`;
        } catch (e) {
            return {
                pass: false,
                score: 0,
                reason: e.message
            };
        }
    }

    return {
        pass,
        score: pass ? 1 : 0,
        reason
    };
}

/**
 * Retrieves the project path from a set of provided variables.
 *
 * @param vars Promptfoo context variables.
 * @returns The project path string if available in passed variables.
 * ```
 */
function getProjectPath(vars: Record<string, string | object>): string | undefined {
    return vars.PROJECT_PATH && typeof vars.PROJECT_PATH === 'string' ? vars.PROJECT_PATH : undefined;
}

/**
 * Parses and validates a raw configuration object into a normalized `SnapshotConfiguration`.
 *
 * @param config A raw configuration record, typically loaded from a test context.
 * @returns A normalized `SnapshotConfiguration` object, or `undefined` if validation fails.
 */
function getConfiguration(config: Record<string, unknown>): SnapshotConfiguration | undefined {
    if (
        'file' in config &&
        typeof config.file === 'string' &&
        'snapshot' in config &&
        typeof config.snapshot === 'string'
    ) {
        let segments: SnapshotSegmentConfig[] | undefined;
        if ('segments' in config && Array.isArray(config.segments)) {
            segments = config.segments.filter((segment) => typeof segment === 'object' && 'path' in segment);
        }
        return {
            snapshot: config.snapshot,
            file: config.file,
            segments
        };
    }
}

/**
 * Ensures the existence of a snapshot file for the given target and returns its data.
 *
 * @param projectPath The absolute path to the current project.
 * @param key A key identifying the snapshot set or namespace.
 * @param targetPath The relative path to the file being compared.
 * @returns A `SnapshotData` object containing both source and snapshot contents.
 */
function getSnapshotData(projectPath: string, key: string, targetPath: string): SnapshotData {
    let snapshotFolder = join(FOLDER_PATHS.snapshots, key);
    const relativeFolder = dirname(join(targetPath));
    if (relativeFolder) {
        snapshotFolder = join(snapshotFolder, relativeFolder);
    }
    // Make sure snapshot folder exists
    if (!fs.existsSync(snapshotFolder)) {
        fs.mkdirSync(snapshotFolder, { recursive: true });
    }
    // Check target file
    const filePath = join(projectPath, targetPath);
    if (!fs.existsSync(filePath)) {
        throw new Error(`${filePath} does not exists`);
    }
    const fileName = basename(filePath);
    const snapshotFile = join(snapshotFolder, fileName);
    let created = false;
    if (!fs.existsSync(snapshotFile)) {
        // Write snapshot
        fs.copyFileSync(filePath, snapshotFile);
        created = true;
    }
    const sourceContent = fs.readFileSync(filePath, 'utf8');
    const snapshotContent = fs.readFileSync(snapshotFile, 'utf8');
    return {
        content: {
            snapshot: snapshotContent,
            source: sourceContent
        },
        created
    };
}

/**
 * Validates that the provided source content matches its corresponding snapshot,
 * optionally comparing specific JSON segments.
 *
 * @param snapshotData The snapshot and source contents to compare.
 * @param config The snapshot configuration specifying comparison behavior.
 * @returns A string describing the first detected difference or `undefined` if the snapshot matches the source.
 */
function validateSnapshot(snapshotData: SnapshotData, config: SnapshotConfiguration): string | undefined {
    let compareResult: string | undefined;
    if (config.segments && config.file.endsWith('.json')) {
        const actual = JSON.parse(snapshotData.content.source);
        const snapshot = JSON.parse(snapshotData.content.snapshot);
        for (const segement of config.segments) {
            const actualSegment = getByPath(actual, segement.path);
            const snapshotSegment = getByPath(snapshot, segement.path);
            if (
                actualSegment !== null &&
                snapshotSegment !== null &&
                typeof actualSegment === 'object' &&
                typeof snapshotSegment === 'object'
            ) {
                if (segement.mode === 'contains') {
                    compareResult = deepContains(snapshotSegment, actualSegment);
                } else {
                    compareResult = compareJson(actualSegment, snapshotSegment);
                }
            } else {
                compareResult =
                    actualSegment === snapshotSegment ? undefined : `Value differs for ${segement.path.join('/')}`;
            }
            if (compareResult !== undefined) {
                break;
            }
        }
    } else {
        compareResult = config.file.endsWith('.json')
            ? compareJson(snapshotData.content.source, snapshotData.content.snapshot)
            : compareStrings(snapshotData.content.source, snapshotData.content.snapshot);
    }
    return compareResult;
}

/**
 * Retrieves a nested value from an object or array using a sequence of keys.
 *
 * @param obj The object or array to traverse.
 * @param path An array of keys or indices representing the access path.
 * @returns The value found at the given path, or `undefined` if any part of the path is invalid.
 */
function getByPath(obj: unknown, path: (string | number)[]): unknown {
    if (!Array.isArray(path)) return undefined;

    let current: unknown = obj;

    for (let i = 0; i < path.length; i++) {
        const key = path[i];
        // Ensure current is an object or array before trying to access properties
        if (
            current === null ||
            typeof current !== 'object' ||
            !(key in (current as Record<string | number, unknown>))
        ) {
            return undefined;
        }

        current = (current as Record<string | number, unknown>)[key];
    }

    return current;
}

/**
 * Compare two json objects or string.
 *
 * @param obj1 First json object or string to compare.
 * @param obj2 Second json object or string to compare.
 * @returns A string describing the differences, or `undefined` if the strings are identical.
 */
function compareJson(obj1: string | object, obj2: string | object): string | undefined {
    const diffChanges = diffJson(obj1, obj2);
    const diffResultString = getDiffResultString(diffChanges);
    return diffResultString ? diffResultString : undefined;
}

/**
 * Recursively checks whether all properties and values of the `expected` object
 * are contained within the `actual` object.
 *
 * @param expected The reference value or object to compare against.
 * @param actual The object or value being tested for containment.
 * @param path (Internal) The current object path used for detailed mismatch reporting.
 * @returns A descriptive error string indicating the first mismatch or missing key,
 *          or `undefined` if `actual` fully contains `expected`.
 */
function deepContains(expected: unknown, actual: unknown, path = ''): string | undefined {
    // Handle primitive values (and null)
    if (typeof expected !== 'object' || expected === null || typeof actual !== 'object' || actual === null) {
        return Object.is(expected, actual) ? undefined : `Mismatch at ${path}: expected ${expected}, got ${actual}`;
    }

    // At this point both are non-null objects
    const expectedObj = expected as Record<string, unknown>;
    const actualObj = actual as Record<string, unknown>;

    for (const key of Object.keys(expectedObj)) {
        if (!(key in actualObj)) {
            return `Missing key at ${path}.${key}`;
        }

        const result = deepContains(expectedObj[key], actualObj[key], `${path}.${key}`);
        if (result) return result;
    }

    // Ignore extra keys in `actual`
    return undefined;
}

/**
 * Compare two strings.
 *
 * @param obj1 First object to compare.
 * @param obj2 Second object to compare.
 * @returns A string describing the differences, or `undefined` if the strings are identical.
 */
function compareStrings(obj1: string, obj2: string): string | undefined {
    const diffChanges = diffTrimmedLines(obj1, obj2);
    const diffResultString = getDiffResultString(diffChanges);
    return diffResultString ? diffResultString : undefined;
}

/**
 * Get the diff results as colored string.
 *
 * @param diffChanges Array of changes, result from diff.
 * @returns Diff results as colored string.
 */
function getDiffResultString(diffChanges: Change[]): string {
    let diffResults: string = '';
    for (const diffChange of diffChanges) {
        if (diffChange.added) {
            diffResults += green(diffChange.value);
        } else if (diffChange.removed) {
            diffResults += red(diffChange.value);
        }
    }
    return diffResults;
}
