<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: vocabularyService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: vocabularyService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vocabularyService_1 = require("./types/vocabularyService");
const loader_1 = require("./loader");
const baseTypes_1 = require("./types/baseTypes");
/**
 * Vocabulary service class
 * @class
 */
class VocabularyService {
    constructor() {
        const vocabularyInformation = loader_1.loadVocabulariesInformation();
        this.dictionary = vocabularyInformation.dictionary;
        this.byTarget = vocabularyInformation.byTarget;
        this.supportedVocabularies = vocabularyInformation.supportedVocabularies;
        this.namespaceByDefaultAlias = vocabularyInformation.namespaceByDefaultAlias;
        this.derivedTypesPerType = vocabularyInformation.derivedTypesPerType;
        this.upperCaseNameMap = vocabularyInformation.upperCaseNameMap;
    }
    resolveName(fullyQualifiedName) {
        const parts = (fullyQualifiedName || '').trim().split('.');
        const name = parts.pop() || '';
        const namespace = parts.join('.');
        return { namespace, name };
    }
    isOfType(type, complyingType) {
        let isOfType = false;
        if (type === complyingType) {
            isOfType = true;
        }
        else if (type.startsWith('Edm.')) {
            if (complyingType.startsWith('Edm.')) {
                // TODO check abstract base types (e.g. Edm.PrimitiveType) ?
                isOfType = complyingType === type;
            }
            else {
                const complyingTypeDef = this.getType(complyingType);
                if (complyingTypeDef &amp;&amp; complyingTypeDef.underlyingType) {
                    isOfType = complyingTypeDef.underlyingType === type;
                }
            }
        }
        else {
            const derivedTargetTypes = this.getDerivedTypeNames(type);
            isOfType = derivedTargetTypes.has(complyingType);
        }
        return isOfType;
    }
    /**
     * Returns map of all vocabularies supported by this library.
     * @returns {Map&lt;Namespace, Vocabulary>} - map of vocabularies
     */
    getVocabularies() {
        return this.supportedVocabularies;
    }
    /**
     * Returns the supported namespace for a qualified name.
     *
     * @param name - Qualified name, i.e. &lt;Namespace|Alias>.&lt;Name>
     * @returns {Namespace} - namespace for a qualified name
     */
    getVocabularyNamespace(name) {
        const resolvedTermNamespace = this.resolveName(name).namespace;
        const vocabulary = this.getVocabulary(name) || this.getVocabulary(resolvedTermNamespace);
        const namespace = vocabulary &amp;&amp; vocabulary.namespace;
        return namespace;
    }
    /**
     * Returns information about a vocabulary identified by its name qualifier.
     *
     * @param nameQualifier - Name qualifier.
     * @returns {Vocabulary | null} - vocabulary information
     */
    getVocabulary(nameQualifier) {
        const namespace = this.namespaceByDefaultAlias.get(nameQualifier) || nameQualifier;
        return this.supportedVocabularies.get(namespace) || null;
    }
    /**
     * Returns all terms which are applicable for a given context.
     *
     * The context is defined by the following parameters:
     *
     * @param targetKinds - Target kinds, see symbolic values in http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Applicability
     * @param targetType  - Type name of the annotated element.
     * @returns {FullyQualifiedName[]} - all terms which are applicable for a given context.
     */
    getTermsForTargetKinds(targetKinds, targetType) {
        let terms = this.byTarget.has('') ? [...this.byTarget.get('').keys()] : [];
        targetKinds.forEach((targetKind) => {
            if (this.byTarget.has(targetKind)) {
                // eliminate duplicates
                terms = terms.concat([...this.byTarget.get(targetKind).keys()]);
                terms = [...new Set(terms).keys()];
            }
        });
        return terms.filter((termName) => {
            const term = this.dictionary.get(termName);
            if (term.constraints &amp;&amp; term.constraints.requiresType) {
                return this.isOfType(term.constraints.requiresType, targetType);
            }
            else {
                return true;
            }
        });
    }
    /**
     * Check if the term is applicable in the given context.
     *
     * The context is described by parameters targetKind and targetType.
     * The result describes whether the term is applicable or gives a reason why it is not applicable.
     *
     * @param termName       - Name of vocabulary term
     * @param targetKind     - Target kind, see symbolic values in http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Applicability
     * @param targetType     - Type of the annotated element
     * @returns                TermApplicability: {IsValid|TermNotApplicable|TypeNotApplicable|UnknownTerm|UnknownVocabulary|UnSupportedVocabulary}
     */
    checkTermApplicability(termName, targetKinds, targetType) {
        const term = this.getTerm(termName);
        const namespace = this.getVocabularyNamespace(termName);
        if (!term &amp;&amp; !this.supportedVocabularies.has(namespace)) {
            return vocabularyService_1.TermApplicability.UnSupportedVocabulary;
        }
        else if (!term) {
            return vocabularyService_1.TermApplicability.UnknownTerm;
        }
        else {
            let applicable = this.byTarget.has('') &amp;&amp; this.byTarget.get('').has(termName);
            for (let i = 0; i &lt; targetKinds.length &amp;&amp; !applicable; i++) {
                applicable = this.byTarget.has(targetKinds[i]) &amp;&amp; this.byTarget.get(targetKinds[i]).has(termName);
            }
            if (!applicable) {
                return vocabularyService_1.TermApplicability.TermNotApplicable;
            }
            else if (targetType &amp;&amp; term.constraints &amp;&amp; term.constraints.requiresType) {
                const requiredType = term.constraints.requiresType;
                return this.isOfType(requiredType, targetType)
                    ? vocabularyService_1.TermApplicability.Applicable
                    : vocabularyService_1.TermApplicability.TypeNotApplicable;
            }
            else {
                return vocabularyService_1.TermApplicability.Applicable;
            }
        }
    }
    /**
     * Returns the documentation for an vocabulary element.
     *
     * The result is an array of Markdown strings.
     *
     * @param name           - Fully qualified name of the element.
     * @param [propertyName] - Name of a property of the element (in case fName is a complex type and you want to get
     *                         the documentation of the property instead of the properties element)
     * @returns {MarkdownString[]} - mark down string.
     */
    getDocumentation(name, propertyName) {
        let element;
        let elementType;
        let enumTypeDocumentation = [];
        let values = [];
        element = this.getTerm(name) || this.getType(name);
        if (element) {
            if (element.kind === 'Term') {
                elementType = this.getElementType(element);
            }
            else if (element.kind === 'ComplexType' &amp;&amp; propertyName) {
                const expandedComplexType = this.getComplexType(name);
                element = expandedComplexType.properties.get(propertyName);
                elementType = this.getElementType(element);
            }
            else if (element.kind === 'EnumType' &amp;&amp; propertyName) {
                enumTypeDocumentation = enumTypeDocumentation.concat(this.getDocumentation(name));
                element = element.values.filter((value) => value.name === propertyName)[0] || null;
            }
            const experimentalTerm = this.getTerm('com.sap.vocabularies.Common.v1.Experimental');
            const experimentalDescription = `${experimentalTerm.description} ${experimentalTerm.longDescription}`;
            const languageDependentDesc = this.getTerm('Org.OData.Core.V1.IsLanguageDependent').description;
            if (element.experimental) {
                const experimental = element.kind === 'Member' ? `**Enum Value Experimental:**` : `**Experimental:**`;
                values.push(`${experimental} ${experimentalDescription} \n`);
            }
            if (element.deprecated) {
                const deprecated = element.kind === 'Member' ? `**Enum Value Depreacated:**` : `**Deprecated:**`;
                values.push(`${deprecated} ${element.deprecatedDescription} \n`);
            }
            if (element.kind &amp;&amp; element.kind !== 'Property') {
                const kind = element.kind === 'Member' ? `**Enum Value Kind:**` : `**Kind:**`;
                values.push(`${kind} ${element.kind} \n`);
            }
            if (element.description) {
                const desciption = element.kind === 'Member' ? `**Enum Value Description:**` : `**Description:**`;
                values.push(`${desciption} ${element.description} \n`);
            }
            if (element.longDescription) {
                const longDesciption = element.kind === 'Member' ? `**Enum Value Long Description:**` : `**Long Description:**`;
                values.push(`${longDesciption} ${element.longDescription} \n`);
            }
            if (element.kind === baseTypes_1.TERM_KIND &amp;&amp; element.baseTerm) {
                values.push(`**Base Term:** ${element.baseTerm} \n`);
            }
            if (element.kind === baseTypes_1.TERM_KIND &amp;&amp; element.appliesTo &amp;&amp; element.appliesTo.length > 0) {
                values.push(`**Applies To:** ${element.appliesTo.join('  ')} \n`);
            }
            if (element.kind !== 'Member') {
                values.push(this.getFormattedTypeText(element, elementType));
            }
            if (elementType &amp;&amp; elementType.description) {
                values.push(`**Type Description:** ${elementType.description} \n`);
            }
            if (elementType &amp;&amp; elementType.longDescription) {
                values.push(`**Type Long Description:** ${elementType.longDescription} \n`);
            }
            if ((element.kind === 'Term' || element.kind === 'Property') &amp;&amp;
                element.constraints &amp;&amp;
                element.constraints.requiresType) {
                values.push(`**Require Type:** ${element.constraints.requiresType} \n`);
            }
            if (elementType &amp;&amp; elementType.experimental) {
                values.push(`**Type Experimental:** ${experimentalDescription} \n`);
            }
            if (elementType &amp;&amp; elementType.deprecated) {
                values.push(`**Type Deprecated:** ${elementType.deprecatedDescription} \n`);
            }
            if (element.kind === baseTypes_1.COMPLEX_TYPE_KIND &amp;&amp; element.baseType) {
                values.push(`**BaseType:** ${element.baseType} \n`);
            }
            if ((element.kind === baseTypes_1.TERM_KIND || element.kind === 'Property') &amp;&amp;
                element.constraints &amp;&amp;
                element.constraints.isLanguageDependent) {
                values.push(`**IsLanguageDependent:** ${languageDependentDesc} \n`);
            }
            if ((element.kind === baseTypes_1.TERM_KIND || element.kind === 'Property') &amp;&amp; element.defaultValue) {
                values.push(`**DefaultValue:** ${element.defaultValue} \n`);
            }
            if (element.kind !== 'Member' &amp;&amp; element.kind !== 'EnumType') {
                values.push(this.getFormattedNullableText(element));
            }
            if (enumTypeDocumentation.length > 0) {
                values = enumTypeDocumentation.concat(values);
            }
        }
        return values;
    }
    getElementType(element) {
        const elementType = this.getType(element.type) || this.getTerm(element.type);
        return elementType;
    }
    getFormattedTypeText(element, elementType) {
        let sResultText = '';
        if (element.kind === baseTypes_1.TERM_KIND || element.kind === 'Property') {
            const type = element.isCollection &amp;&amp; element.type ? `Collection(${element.type}) \n` : element.type;
            if (elementType &amp;&amp; elementType.experimental) {
                sResultText = `**Type:** ${type}(**experimental**) \n`;
            }
            else if (elementType &amp;&amp; elementType.deprecated) {
                sResultText = `**Type:** ${type}(**deprecated**) \n`;
            }
            else {
                sResultText = `**Type:** ${type} \n`;
            }
        }
        return sResultText;
    }
    getFormattedNullableText(object) {
        let sResultText = '';
        const isNullable = (object.kind === baseTypes_1.TERM_KIND || object.kind === 'Property' || object.kind === baseTypes_1.TYPE_DEFINITION_KIND) &amp;&amp;
            !!object.facets &amp;&amp;
            !!object.facets.isNullable;
        const isCollection = (object.kind === baseTypes_1.TERM_KIND || object.kind === 'Property') &amp;&amp; object.isCollection;
        if (isNullable &amp;&amp; isCollection) {
            sResultText = `**Nullable Item:** ${isNullable} \n`;
        }
        else if (!isNullable &amp;&amp; isCollection) {
            sResultText = `**Nullable Item:** false \n`;
        }
        else if (isNullable) {
            sResultText = `**Nullable:** true \n`;
        }
        else if (!isNullable) {
            sResultText = `**Nullable:** false \n`;
        }
        else {
            sResultText = '';
        }
        return sResultText;
    }
    /**
     * Returns information about a term.
     *
     * @param termName - Fully qualified name of a term.
     * @returns {Term} - Term.
     */
    getTerm(termName) {
        const vocabularyObject = this.dictionary.get(termName);
        return vocabularyObject &amp;&amp; vocabularyObject.kind === baseTypes_1.TERM_KIND ? vocabularyObject : null;
    }
    /**
     * Returns information about a vocabulary type.
     *
     * @param typeName - Fully qualified name of the type.
     * @returns {VocabularyType} - information about a vocabulary type.
     */
    getType(typeName) {
        const vocabularyObject = this.dictionary.get(typeName);
        return vocabularyObject &amp;&amp; vocabularyObject.kind !== baseTypes_1.TERM_KIND ? vocabularyObject : null;
    }
    /**
     * Returns the names of all derived types for a given type (including the provided type name)
     *
     * @param typeName        - Name of the vocabulary type for which you want to get the derived types
     * @param includeAbstract - true: include names of abstract types in addition to concrete types,
     *                          false: return concrete types only
     * @returns {Set&lt;FullyQualifiedName>} - names of all derived types for a given type
     */
    getDerivedTypeNames(typeName, includeAbstract) {
        let names = [];
        const type = this.dictionary.get(typeName);
        if (type &amp;&amp; type.kind === baseTypes_1.COMPLEX_TYPE_KIND) {
            // recursively collect all derived types
            names.push({ fName: typeName, isAbstract: type.isAbstract });
            for (let i = 0; i &lt; names.length; i++) {
                const name = names[i].fName;
                (this.derivedTypesPerType.get(name) || new Map()).forEach((isAbstract, derivedName) => {
                    names.push({ fName: derivedName, isAbstract: isAbstract });
                });
            }
            // filter out abstract types if required
            if (!includeAbstract) {
                names = names.filter((entry) => !entry.isAbstract);
            }
        }
        return new Set(names.map((entry) => entry.fName));
    }
    /**
     * Returns the complex type information for a given type name.
     *
     * The result also contains the aggregated information of the basetype chain.
     *
     * @param typeName - Fully qualified name of the type.
     * @returns {ExpandedComplexType} complex type information for a given type name.
     */
    getComplexType(typeName) {
        let expandedComplexType = null;
        const dictionaryType = this.dictionary.get(typeName);
        let complexType = dictionaryType &amp;&amp; dictionaryType.kind === baseTypes_1.COMPLEX_TYPE_KIND ? dictionaryType : null;
        if (complexType) {
            expandedComplexType = Object.assign({}, complexType, { baseTypes: [] });
            while (complexType &amp;&amp; complexType.baseType) {
                // isOpenType of base type might affect resolvedType: but currently not in supported vocabularies
                expandedComplexType.baseTypes.push(complexType.baseType);
                complexType = this.dictionary.get(complexType.baseType);
                if (complexType &amp;&amp; complexType.properties) {
                    complexType.properties.forEach((property, name) => {
                        expandedComplexType.properties.set(name, property);
                    });
                }
            }
            delete expandedComplexType['baseType'];
        }
        if (expandedComplexType) {
            delete expandedComplexType['baseType'];
        }
        return expandedComplexType;
    }
    /**
     * Returns a property of an complex type.
     *
     * The result also contains the properties of the basetype chain.
     *
     * @param typeName     - Fully qualified name of complex type.
     * @param propertyName - Name of the property to return.
     * @returns {ComplexTypeProperty} - property of an complex type.
     */
    getComplexTypeProperty(typeName, propertyName) {
        let property = null;
        const dictionaryType = this.dictionary.get(typeName);
        let complexType = dictionaryType &amp;&amp; dictionaryType.kind === baseTypes_1.COMPLEX_TYPE_KIND ? dictionaryType : null;
        if (complexType) {
            property = complexType.properties.get(propertyName);
            while (!property &amp;&amp; complexType.baseType) {
                complexType = this.dictionary.get(complexType.baseType);
                property = complexType.properties.get(propertyName);
            }
        }
        return property;
    }
}
exports.VocabularyService = VocabularyService;
//# sourceMappingURL=vocabularyService.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="VocabularyService.html">VocabularyService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Edm">Edm</a></li><li><a href="global.html#EdmType">EdmType</a></li><li><a href="global.html#EdmxElementName">EdmxElementName</a></li><li><a href="global.html#getVocabulary">getVocabulary</a></li><li><a href="global.html#PROPERTY_KIND">PROPERTY_KIND</a></li><li><a href="global.html#TargetKindValue">TargetKindValue</a></li><li><a href="global.html#TermApplicability">TermApplicability</a></li><li><a href="global.html#TYPE_DEFINITION_KIND">TYPE_DEFINITION_KIND</a></li><li><a href="global.html#updateVocabularies">updateVocabularies</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Tue Mar 31 2020 14:06:58 GMT+0100 (Irish Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
