import { dirname, join, relative } from 'path';
import { create as createStorage } from 'mem-fs';
import { create, type Editor } from 'mem-fs-editor';
import hasbin = require('hasbin');
import { spawnSync } from 'child_process';
import { UI5Config as UI5ConfigInstance } from '@sap-ux/ui5-config';
import {
    type Manifest,
    getMtaPath,
    findCapProjectRoot,
    readUi5Yaml,
    FileName,
    updatePackageScript,
    addPackageDevDependency
} from '@sap-ux/project-access';
import { Authentication } from '@sap-ux/btp-utils';
import {
    MTAExecutable,
    CDSExecutable,
    CDSBinNotFound,
    MTABinNotFound,
    NoAuthType,
    CDSAddMtaParams,
    MTAYamlFile,
    DefaultMTADestination,
    EmptyDestination,
    XSAppFile,
    MTABuildScript,
    AppDeployMTAScript,
    UndeployMTAScript,
    UI5DeployBuildScript,
    RootDeployMTAScript,
    MTAPackage,
    Rimraf,
    RimrafVersion,
    MTAPackageVersion,
    MTAFileExtension,
    WelcomeFile,
    XSSecurityFile
} from '../constants';
import {
    readManifest,
    getTemplatePath,
    toPosixPath,
    findRoute,
    getDestinationProperties,
    addGitIgnore,
    addRootPackage,
    addXSSecurity
} from '../utils';
import {
    type MtaConfig,
    getMtaConfig,
    getMtaId,
    toMtaModuleName,
    createMTA,
    useAbapDirectServiceBinding
} from '../mta-config';
import { t } from '../i18n';
import { type Logger } from '@sap-ux/logger';
import { type UI5Config, type FioriToolsProxyConfig } from '@sap-ux/ui5-config';
import { type CFConfig, type CFAppConfig, type XSAppDocument, ApiHubType, type MTABaseConfig } from '../types';

/**
 * Adds a standalone | managed approuter configuration to a HTML5 application.
 *
 * @param cfAppConfig writer configuration
 * @param fs file system reference
 * @param logger logger
 * @returns file system reference
 */
export async function generateAppConfig(cfAppConfig: CFAppConfig, fs?: Editor, logger?: Logger): Promise<Editor> {
    if (!fs) {
        fs = create(createStorage());
    }
    // CF writer is dependent on the mta-lib library, which in turn relies on the mta executable being installed and available in the path
    if (!hasbin.sync(MTAExecutable)) {
        throw new Error(MTABinNotFound);
    }
    await generateDeployConfig(cfAppConfig, fs, logger);
    return fs;
}

async function getUpdatedConfig(cfAppConfig: CFAppConfig, fs: Editor, logger?: Logger): Promise<CFConfig> {
    let isCap = false;
    let mtaPath;
    let mtaId;
    let rootPath;

    const foundMtaPath = await getMtaPath(cfAppConfig.appPath);
    if (foundMtaPath) {
        mtaPath = dirname(foundMtaPath.mtaPath);
        mtaId = await getMtaId(mtaPath);
    }
    const capRoot = await findCapProjectRoot(cfAppConfig.appPath);
    if (capRoot) {
        // CDS executable is required for CAP projects as the mta.yaml file is generated by the cds deploy command
        if (!hasbin.sync(CDSExecutable)) {
            throw new Error(CDSBinNotFound);
        }
        isCap = true;
        rootPath = capRoot;
    } else {
        rootPath = mtaPath ? dirname(mtaPath) : cfAppConfig.appPath;
    }

    const { serviceBase, destination } = await processUI5Config(cfAppConfig.appPath, fs);
    const { servicePath, firstServicePathSegment, appId } = await processManifest(cfAppConfig.appPath, fs);
    const { isFullUrlDest, destinationAuthType } = await getDestinationProperties(
        cfAppConfig.destination ?? destination
    );
    const config = {
        appPath: cfAppConfig.appPath.replace(/\/$/, ''),
        destination: cfAppConfig.destination ?? destination,
        addManagedApprouter: cfAppConfig.addManagedApprouter ?? false,
        lcapMode: !isCap ? false : true,
        isMtaRoot: foundMtaPath?.hasRoot ?? false,
        useAbapDirectSrvBinding: mtaPath ? await useAbapDirectServiceBinding(mtaPath) : false,
        addMTADestination: cfAppConfig.addMTADestination ?? true,
        serviceBase: cfAppConfig.serviceHost ?? serviceBase,
        mtaId,
        mtaPath,
        destinationAuthType,
        isCap,
        servicePath,
        firstServicePathSegment,
        appId,
        rootPath: rootPath.replace(/\/$/, ''),
        capRoot,
        isFullUrlDest
    } as CFConfig;
    logger?.debug(`CF Config completed: ${JSON.stringify(config, null, 2)}`);
    return config;
}

async function processUI5Config(
    appPath: string,
    fs: Editor,
    logger?: Logger
): Promise<{
    serviceBase: string | undefined;
    destination: string | undefined;
    firstServicePathSegment: string | undefined;
}> {
    try {
        let configDestination;
        let serviceBase;
        let firstServicePathSegment;
        const ui5YamlConfig: UI5Config = await readUi5Yaml(appPath, FileName.Ui5Yaml, fs);
        const toolsConfig = ui5YamlConfig.findCustomMiddleware<FioriToolsProxyConfig>('fiori-tools-proxy');
        if (toolsConfig?.configuration?.backend?.length === 1) {
            configDestination = toolsConfig?.configuration?.backend[0].destination;
            serviceBase = toolsConfig?.configuration?.backend[0].url;
            firstServicePathSegment = toolsConfig?.configuration?.backend[0].path;
        }
        return { destination: configDestination, serviceBase, firstServicePathSegment };
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'processUI5Config' }));
        throw error;
    }
}

async function processManifest(
    appPath: string,
    fs: Editor,
    logger?: Logger
): Promise<{
    servicePath: string | undefined;
    firstServicePathSegment: string | undefined;
    appId: string | undefined;
}> {
    try {
        const manifest = await readManifest(join(appPath, 'webapp/manifest.json'), fs);
        const appId = toMtaModuleName(manifest?.['sap.app']?.id);
        const servicePath = manifest?.['sap.app']?.dataSources?.mainService?.uri;
        const firstServicePathSegment = servicePath?.substring(0, servicePath?.indexOf('/', 1));
        return { servicePath, firstServicePathSegment, appId };
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'processManifest' }));
        throw error;
    }
}

async function generateDeployConfig(cfAppConfig: CFAppConfig, fs: Editor, logger?: Logger): Promise<void> {
    const cfConfig = await getUpdatedConfig(cfAppConfig, fs);
    // Generate MTA Config, LCAP will generate the mta.yaml on the fly so we dont care about it!
    if (!cfConfig.lcapMode) {
        createMTAConfig(cfConfig, fs, logger);
        await generateRootConfig(cfConfig, fs, logger);
        await updateMtaConfig(cfConfig, logger);
    }
    // Generate HTML5 config
    await generateAppConfig(cfConfig, fs, logger);

    // Update configurations
    if (cfConfig.mtaId && !cfConfig.addManagedApprouter) {
        await cleanupStandaloneMtaConfig(cfConfig, fs, logger);
    }
    await updateManifest(cfConfig, fs, logger);
    await updateHTML5AppPackage(cfConfig, fs, logger);
    await updateRootPackage(cfConfig, fs, logger);
}

function createMTAConfig(cfConfig: CFConfig, fs: Editor, logger?: Logger): void {
    if (!cfConfig.mtaId) {
        try {
            if (cfConfig.isCap) {
                const result = spawnSync(CDSExecutable, CDSAddMtaParams, {
                    cwd: cfConfig.rootPath
                });
                if (result.error) {
                    throw new Error(CDSBinNotFound);
                }
            } else {
                createMTA(
                    { mtaId: cfConfig.appId, mtaPath: cfConfig.mtaPath ?? cfConfig.rootPath } as MTABaseConfig,
                    fs
                );
            }
            cfConfig.mtaId = cfConfig.appId;
            cfConfig.mtaPath = cfConfig.rootPath;
            logger?.debug(`MTA Created at ${join(cfConfig.rootPath, MTAYamlFile)}`);
        } catch (error) {
            logger?.debug(t('debug.logError', { error, method: 'createMTAConfig' }));
            throw error;
        }
    }
}

/**
 * Generate CF specific configurations to support deployment and undeployment.
 *
 * @param config
 * @param fs
 * @param logger
 */
async function generateRootConfig(config: CFConfig, fs: Editor, logger?: Logger): Promise<void> {
    try {
        const mtaId: string | undefined = config.mtaId ?? (await getMtaId(config.rootPath));
        // Add specific MTA ID configurations
        const mtaConfig = { mtaId: mtaId ?? config.appId, mtaPath: config.rootPath } as MTABaseConfig;
        if (mtaId && !fs.exists(join(config.rootPath, 'package.json'))) {
            addRootPackage(mtaConfig, fs);
        }
        if (config.addManagedApprouter && !fs.exists(join(config.rootPath, XSSecurityFile))) {
            addXSSecurity(mtaConfig, fs);
        }
        // Be a good developer and add a gitignore if missing from the existing project root
        if (!fs.exists(join(config.rootPath, '.gitignore'))) {
            addGitIgnore(config.rootPath, fs);
        }
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'generateRootConfig' }));
        throw error;
    }
}

async function updateMtaConfig(cfConfig: CFConfig, logger?: Logger): Promise<void> {
    try {
        const mtaConfig = await getMtaConfig(cfConfig.rootPath);
        if (mtaConfig) {
            await mtaConfig.addRoutingModules(cfConfig.addManagedApprouter);
            const appModule = cfConfig.appId;
            const appRelativePath = toPosixPath(relative(cfConfig.rootPath, cfConfig.appPath));
            await mtaConfig.addApp(appModule, appRelativePath ? appRelativePath : '.');
            await mtaConfig.updateParameters();
            if ((cfConfig.addMTADestination && cfConfig.isCap) || cfConfig.destination === DefaultMTADestination) {
                const tmpDestination =
                    cfConfig.destination === DefaultMTADestination
                        ? mtaConfig.getFormattedPrefix(DefaultMTADestination)
                        : cfConfig.destination;
                await mtaConfig.appendInstanceBasedDestination(tmpDestination);
                // This is required where a managed or standalone router hasnt been added yet to mta.yaml
                if (!mtaConfig.hasManagedXsuaaResource()) {
                    cfConfig.destinationAuthType = Authentication.NO_AUTHENTICATION;
                }
            }
            await saveMta(cfConfig, mtaConfig, logger);
            cfConfig.cloudServiceName = mtaConfig.cloudServiceName;
        }
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'updateMtaConfig' }));
        throw error;
    }
}

async function saveMta(cfConfig: CFConfig, mtaConfig: MtaConfig, logger?: Logger): Promise<void> {
    try {
        if (await mtaConfig.save()) {
            // Add mtaext if required for API Hub Enterprise connectivity
            if (cfConfig.apiHubConfig?.apiHubType === ApiHubType.apiHubEnterprise) {
                try {
                    await mtaConfig.addMtaExtensionConfig(cfConfig.destination, cfConfig.serviceBase, {
                        key: 'ApiKey',
                        value: cfConfig.apiHubConfig.apiHubKey
                    });
                } catch (error) {
                    logger?.error(t('ERROR_MTA_EXTENSION_FOR_ABHE_FAILED', { error }));
                }
            }
        }
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'saveMta' }));
    }
}

async function generateAppConfig(cfConfig: CFConfig, fs: Editor, logger?: Logger): Promise<void> {
    try {
        // When data source is none in app generator, it is not required to provide destination
        if (cfConfig.destination && cfConfig.destination !== EmptyDestination) {
            fs.copyTpl(getTemplatePath('app/xs-app-destination.json'), join(cfConfig.appPath, XSAppFile), {
                destination: cfConfig.destination,
                servicePathSegment: `${cfConfig.firstServicePathSegment}${cfConfig.isFullUrlDest ? '/.*' : ''}`, // For service URL's, pull out everything after the last slash
                targetPath: `${cfConfig.isFullUrlDest ? '' : cfConfig.firstServicePathSegment}/$1`, // Pull group 1 from the regex
                authentication: cfConfig.destinationAuthType === NoAuthType ? 'none' : 'xsuaa'
            });
        } else {
            fs.copyTpl(getTemplatePath('app/xs-app-no-destination.json'), join(cfConfig.appPath, XSAppFile));
        }
        await generateUI5DeployConfig(cfConfig, fs);
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'generateAppConfig' }));
        throw error;
    }
}

async function updateManifest(cfConfig: CFConfig, fs: Editor, logger?: Logger): Promise<void> {
    try {
        const manifest = await readManifest(join(cfConfig.appPath, 'webapp/manifest.json'), fs);
        if (manifest && cfConfig.cloudServiceName) {
            const sapCloud = {
                ...(manifest['sap.cloud'] || {}),
                public: true,
                service: cfConfig.cloudServiceName
            } as Manifest['sap.cloud'];
            fs.extendJSON(join(cfConfig.appPath, 'webapp/manifest.json'), {
                'sap.cloud': sapCloud
            });
        }
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'updateManifest' }));
        throw error;
    }
}

async function updateHTML5AppPackage(cfConfig: CFConfig, fs: Editor, logger?: Logger): Promise<void> {
    try {
        let deployArgs: string[] = [];
        if (fs.exists(join(cfConfig.appPath, MTAFileExtension))) {
            deployArgs = ['-e', MTAFileExtension];
        }
        await updatePackageScript(cfConfig.appPath, 'build:cf', UI5DeployBuildScript, fs);
        await updatePackageScript(cfConfig.appPath, 'build:mta', MTABuildScript, fs);
        await updatePackageScript(cfConfig.appPath, 'deploy', AppDeployMTAScript(deployArgs), fs);
        await updatePackageScript(
            cfConfig.appPath,
            'undeploy',
            UndeployMTAScript(cfConfig.mtaId ?? cfConfig.appId),
            fs
        );
        addCommonDependencies(cfConfig.appPath, fs);
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'updateHTML5AppPackage' }));
        throw error;
    }
}

/**
 * Update the root package.json with scripts to deploy the MTA.
 * @param cfConfig
 * @param fs
 * @param logger
 */
async function updateRootPackage(cfConfig: CFConfig, fs: Editor, logger?: Logger): Promise<void> {
    try {
        const packageExists = fs.exists(join(cfConfig.rootPath, 'package.json'));
        // Append mta scripts only if mta.yaml is a different level to the HTML5 app
        if (cfConfig.isMtaRoot && packageExists) {
            let deployArgs: string[] = [];
            if (fs.exists(join(cfConfig.rootPath, MTAFileExtension))) {
                deployArgs = ['-e', MTAFileExtension];
            }
            [
                { name: 'undeploy', run: UndeployMTAScript(cfConfig.mtaId ?? cfConfig.appId) },
                { name: 'build', run: `${MTABuildScript} --mtar archive` },
                { name: 'deploy', run: RootDeployMTAScript(deployArgs) }
            ].forEach((script) => {
                updatePackageScript(cfConfig.rootPath, script.name, script.run, fs);
            });
            addCommonDependencies(cfConfig.rootPath, fs);
        }
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'updateRootPackage' }));
        throw error;
    }
}

/**
 * Add common dependencies to the HTML5 app package.json.
 * @param packagePath
 * @param fs
 */
function addCommonDependencies(packagePath: string, fs: Editor): void {
    addPackageDevDependency(packagePath, Rimraf, RimrafVersion, fs);
    addPackageDevDependency(packagePath, MTAPackage, MTAPackageVersion, fs);
}

/**
 * Cleanup the standalone MTA config.
 * @param cfConfig
 * @param fs
 * @param logger
 */
async function cleanupStandaloneMtaConfig(cfConfig: CFConfig, fs: Editor, logger?: Logger): Promise<void> {
    try {
        const mtaConfig = await getMtaConfig(cfConfig.rootPath);
        if (mtaConfig?.standaloneRouterPath) {
            // Step1. Do some cleanup!
            const mtaRouterXsAppPath = join(mtaConfig.standaloneRouterPath, XSAppFile);
            const routerXSAppDoc = fs.readJSON(mtaRouterXsAppPath) as unknown as XSAppDocument;
            try {
                if (routerXSAppDoc?.[WelcomeFile] === '/') {
                    routerXSAppDoc[WelcomeFile] = `/${cfConfig.mtaId}`;
                    fs.writeJSON(mtaRouterXsAppPath, routerXSAppDoc);
                }
            } catch (error) {
                logger?.debug(
                    t('debug.logError', { error, method: 'cleanupStandaloneMtaConfigs->editing xs-app.json' })
                );
            }
            // Step2. Read direct service binding config from app router xs-app.json, and set them in HTML5 xs-app.json
            if (routerXSAppDoc && cfConfig.useAbapDirectSrvBinding) {
                const mtaRouterRoute = findRoute(routerXSAppDoc, ['service', 'endpoint']);
                const routerService = mtaRouterRoute?.['service'];
                const routerEndpoint = mtaRouterRoute?.['endpoint'];
                const appXsAppPath = join(cfConfig.appPath, XSAppFile);
                const appXsAppObj = fs.readJSON(appXsAppPath) as unknown as XSAppDocument;
                let destinationRoute = findRoute(appXsAppObj, ['destination'], ['DIRECT_SERVICE_BINDING']);
                if (!destinationRoute) {
                    destinationRoute = findRoute(appXsAppObj, ['service', 'endpoint']);
                }
                if (destinationRoute && routerService && routerEndpoint) {
                    delete destinationRoute['destination'];
                    destinationRoute['service'] = routerService;
                    destinationRoute['endpoint'] = routerEndpoint;
                    fs.writeJSON(appXsAppPath, appXsAppObj);
                }
            }
        }
    } catch (error) {
        logger?.debug(t('debug.logError', { error, method: 'cleanupStandaloneMtaConfigs' }));
        throw error;
    }
}

/**
 * Generate UI5 deploy config.
 *
 * @param cfConfig - the deploy config
 * @param fs - the Editor instance
 * @returns the deploy config
 */
export async function generateUI5DeployConfig(cfConfig: CFConfig, fs: Editor): Promise<void> {
    const ui5BaseConfig = await readUi5Yaml(cfConfig.appPath, FileName.Ui5Yaml, fs);
    const addTranspileTask = !ui5BaseConfig.findCustomMiddleware('ui5-tooling-transpile-task');
    const addModulesTask = !ui5BaseConfig.findCustomMiddleware('ui5-tooling-modules-task');
    const baseUi5Doc = ui5BaseConfig.removeConfig('server');
    const ui5DeployConfig = await UI5ConfigInstance.newInstance(baseUi5Doc.toString());
    ui5DeployConfig.addComment({
        comment: ' yaml-language-server: $schema=https://sap.github.io/ui5-tooling/schema/ui5.yaml.json',
        location: 'beginning'
    });
    ui5DeployConfig.addCloudFoundryDeployTask(cfConfig.appId, addModulesTask, addTranspileTask);
    fs.write(join(cfConfig.appPath, FileName.UI5DeployYaml), ui5DeployConfig.toString());
}
