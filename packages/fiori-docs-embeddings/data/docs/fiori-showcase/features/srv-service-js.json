{
  "id": "fiori-showcase-srv-service-js",
  "title": "service",
  "category": "features",
  "path": "srv/service.js",
  "lastModified": "2025-09-01T18:17:10.731Z",
  "tags": [
    "features",
    "js",
    "service"
  ],
  "headers": [
    "determineFieldWithCriticalityValue",
    "createChildEntities2",
    "createChildEntities1",
    "createChildEntities3",
    "createChartEntities",
    "cleanUpDatabaseEntities"
  ],
  "content": "# service.md\n\n```javascript\n# service.md\n\n```javascript\n# service.md\n\n```javascript\n# service.md\n\n```javascript\n# service.md\n\n```javascript\n# service.md\n\n```javascript\n# service.md\n\n```javascript\n# service.md\n\n```javascript\n# service.js\n\n```javascript\nconst cds = require(\"@sap/cds\");\n\nmodule.exports = async (srv) => {\n\n    const {Singleton, RootEntities,ChildEntities1,ChildEntities2,ChildEntities3,GrandChildEntities,ChartDataEntities, Contacts, Countries,Criticality,Currencies,UnitOfMeasureCodeList} = srv.entities;\n\n    srv.on('READ', Singleton, (req) => {\n        const response = {\n            createHidden: false,\n            enabled: true\n        }\n        req.reply(response)\n    })\n\n    srv.after([\"READ\"],RootEntities, async (response) => {\n        //To avoid issues with cds watch when it is reloading\n        if(!response) return;\n\n        //Create Address Label of contact\n        //The address label is a property which contains all address information of a contact in a single string\n        //To avoid managing the properties itself and the string, the concatination is done\n        //The concatination is only done, if the addressLabel is requested and the contact ID is available\n        if(response.hasOwnProperty('contact') && response.contact.addressLabel === null) {\n            //Requesting the \n            const contact =  await SELECT.one.from(Contacts,response.contact.ID, contact => {\n                contact.ID, contact.building, contact.street, contact.postCode, contact.city, contact.country (country => {\n                    country.name\n                })\n                });\n            response.contact.addressLabel = `${contact.building}\\n${contact.street}\\n${contact.postCode} ${contact.city}\\n${contact.country.name}`;\n            await UPDATE(Contacts,response.contact.ID).with({addressLabel : response.contact.addressLabel}); //Update the persistence with the generated value\n        }\n\n        //Calculate Chart Criticality Values\n        //Only calculate, if the chartEntities (source) is part of the request and is not empty (would be useless to calculate)\n        if(response.hasOwnProperty('chartEntities') && response.chartEntities.length > 0) {\n            //If the forecast or target Value is not given, they should be requested and when the request is empty they should be generated\n            //Both value are needed to fill in the values needed for the criticality calculation\n            if(!response.chartEntities[0].hasOwnProperty('forecastValue') || !response.chartEntities[0].hasOwnProperty('targetValue')) {\n                //Requesting all chart entities and create a map, where the chart entity Id is key and an object containing target and forecast value is the value\n                const chartEntities =  new Map((await SELECT.from(ChartDataEntities, item => {\n                    item.ID, item.forecastValue, item.targetValue\n                }).where({parent_ID : response.ID})).map(key => [key.ID, { forecastValue: key.forecastValue, targetValue: key.targetValue }]));\n                //Calculating the forcast and target Value of each chart entity\n                response.chartEntities.forEach(async e => {\n                    e.forecastValue = (chartEntities.get(e.ID) != undefined) ? chartEntities.get(e.ID).forecastValue : e.integerValue + 10;\n                    e.targetValue = (chartEntities.get(e.ID) != undefined) ? chartEntities.get(e.ID).targetValue : e.integerValue + 20;\n                })\n            }\n            //Calculate the values important for the criticality calculation\n            //This is done to avoid manageing all these value in the csv file\n            response.chartEntities.forEach(e => {\n                e.areaChartToleranceUpperBoundValue = e.integerValue + Math.round((e.integerValue / e.targetValue) *5 + 15);\n                e.areaChartToleranceLowerBoundValue = e.integerValue - Math.round((e.integerValue / e.targetValue) *5 + 15);\n                e.areaChartDeviationUpperBoundValue = e.forecastValue + Math.round((e.integerValue / e.forecastValue) *10 + 30);\n                e.areaChartDeviationLowerBoundValue = e.forecastValue - Math.round((e.integerValue / e.forecastValue) *10 + 30);\n            });\n        }\n    });\n\n    //Filling of properties, when a new RootEntity is created\n    srv.before('NEW',RootEntities, async (req) => {\n        req.data.contact_ID = (await SELECT.one.from(Contacts, contact => {contact.ID})).ID; //Default Contact to prevent Error when creating address label\n        //Generating chart entities, so the charts are not empty - the user has no option to fill in chart entity values in the UI\n        req.data.chartEntities = [];\n        for(let i = 1; i <= 10; i++) {\n            req.data.chartEntities.push({\n                ID : cds.utils.uuid(),\n                parent_ID : req.data.ID,\n                uom_code : 'EA',\n                dimensions : i,\n                integerValue : i+30,\n                forecastValue : i*2+35,\n                targetValue : i*1.6+36,\n                criticality_code : i % 4,\n                DraftAdministrativeData_DraftUUID : req.data.DraftAdministrativeData_DraftUUID\n            });\n        }\n    })\n\n    //=============================================================================================================\n    //      Actions\n    //=============================================================================================================\n\n    srv.on(\"changeCriticality\",RootEntities, async (req) => {\n        //Req.data contains the parameter values of the action\n        //Req.params contains IDs and Draft IDs of the entity\n        const criticality_code = req.data.newCriticality, headerID = req.params[0].ID;\n        //Update the current RootEntity with the new value for ciritcality_code and fieldWithCriticality  \n        return UPDATE(RootEntities,headerID).with({criticality_code : criticality_code, fieldWithCriticality : determineFieldWithCriticalityValue(criticality_code)});\n    });\n\n    function determineFieldWithCriticalityValue(criticality_code) {\n        let fieldWithCriticality = '';\n        switch(criticality_code) {\n            case 0:\n                fieldWithCriticality = 'Neutral'\n                break;\n            case 1:\n                fieldWithCriticality = 'Negative'\n                break;\n            case 2:\n                fieldWithCriticality = 'Critical'\n                break;\n            case 3:\n                fieldWithCriticality = 'Positive'\n                break;\n            case 5:\n                fieldWithCriticality = 'New Item'\n                break;\n            default:\n                fieldWithCriticality = 'Unknown criticality';\n                break;\n        }\n        return fieldWithCriticality;\n    }\n\n\n    srv.on(\"changeProgress\",RootEntities, async (req) => {\n        const integerValue = req.data.newProgress, headerID = req.params[0].ID;\n        return UPDATE(RootEntities,headerID).with({integerValue})\n    });\n\n    //Returns the input parameter as a message to the front end. The message will show up in a dialog.\n    srv.on(\"unboundAction\", async req => {\n        return req.info(`INPUT: ${req.data.input}`);\n    });\n\n    //Returns a message toast at the bottom of the screen, indicating that the action was triggered.\n    srv.on(\"criticalAction\", async req => {\n        return req.notify(`Critical action pressed`); //Search-Term: #MessageToast\n    });\n\n    //Reseting all entities to there default state\n    srv.on(\"resetEntities\", async req => { \n        //Delete current data\n        await cleanUpDatabaseEntities();\n        //Create new entities\n        const countRootEntities = 4;\n        const association2oneIDs = await createChildEntities2(countRootEntities);\n        const rootEntities = [];\n        const imageUrls = ['sap-icon://lab','/media/crate.png','/media/bigBen.png','sap-icon://cart']\n        const contacts = await SELECT.from(Contacts).columns('ID');\n        const unitOfMeasures = await SELECT.from(UnitOfMeasureCodeList).columns('code');\n        const currencies = await SELECT.from(Currencies).columns('code');\n        const criticaityCodes = await SELECT.from(Criticality).columns('code');\n        const countries = await SELECT.from(Countries).columns('code');\n        for(let i = 0; i < countRootEntities; i++) {\n            const date = new Date();\n            let date2 = new Date(date.toISOString());\n            date2.setMonth(date2.getMonth()+3);\n            let uuid = cds.utils.uuid();\n            rootEntities.push({\n                ID: uuid,\n                contact_ID: (i >= contacts.length) ? contacts[0].ID : contacts[i].ID,\n                association2one_ID: association2oneIDs[i],\n                imageUrl: (i >= imageUrls.length) ? imageUrls[0] : imageUrls[i],\n                uom_code: (i >= unitOfMeasures.length) ? unitOfMeasures[0].code : unitOfMeasures[i].code,\n                isoCurrency_code: (i >= currencies.length) ? currencies[0].code : currencies[i].code,\n                criticality_code: (i >= criticaityCodes.length) ? criticaityCodes[0].code : criticaityCodes[i].code,\n                country_code: (i >= countries.length) ? countries[0].code : countries[i].code,\n                //Calculating values, just to have values for the UI. The generation has no special logic behind it.\n                stringProperty: (i===0) ? `Root entity ${i+1} and delete not possible` : (i===1) ? `Root entity ${i+1} and update not possible` : `Root entity ${i+1}`,\n                deletePossible: (i===0) ? false : true,\n                updateHidden: (i===1) ? true : false,\n                dimensions: ((i+1)*2===6) ? i*2 : (i+1)*2, //manipulate values, that two entities have one dimension for demonstrating aggregation on ALP floorplan\n                validFrom: date.toISOString().substring(0,11),\n                validTo: date2.toISOString().substring(0,11),\n                time: `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`,\n                timeStamp: date.toISOString(),\n                fieldWithUoM: i*49+49,\n                fieldWithPrice: i*100,\n                fieldWithCriticality: determineFieldWithCriticalityValue((i === criticaityCodes.length) ? criticaityCodes[0] : criticaityCodes[i]),\n                integerValue: 20+2*i,\n                forecastValue: 20+2*i+(10*i),\n                targetValue: 20+2*i+(10*(i+2)),\n                starsValue: (Math.random()*40)/10, //Value has to be between 0 and 4\n                //Fixed properties\n                email: 'test.test@sap.com',\n                telephone: '+49-6227-12383-2',\n                fieldWithURL: 'https://www.sap.com;',\n                fieldWithURLtext: 'SAP',\n                description: 'Lorem ipsum dolor sit amet, \\n consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.',\n                //Compositions to many:\n                childEntities1: await createChildEntities1(3,uuid),\n                childEntities3: await createChildEntities3(2,uuid),\n                chartEntities: await createChartEntities(10,uuid),\n            });\n        }\n        await cds.tx(req).run(INSERT.into(RootEntities).entries(rootEntities));\n        return req.notify(`All entitiy data has been reseted!`);\n    });\n\n    async function createChildEntities2(countRootEntities) {\n        const childEntities2IDs = [];\n        for(let i = 0; i <= countRootEntities; i++) {\n            childEntities2IDs.push(cds.utils.uuid());\n        }\n        const childEntities2 = [];\n        for(let i = 0; i <= countRootEntities; i++) {\n            childEntities2.push({\n                ID: childEntities2IDs[i],\n                stringProperty: 'fieldValue',\n                integerProperty: i*2+20,\n                decimalProperty: 30+i/10,\n                country_code: 'FR',\n            });\n        }\n        await INSERT.into(ChildEntities2).entries(childEntities2);\n        //Returns the IDs, so they can be assigned to the association2one_ID property of the RootEntities\n        return childEntities2IDs;\n    }\n\n    async function createChildEntities1(amount, parent_ID) {\n        let childEntities1 = [];\n        for(let i = 0; i < amount; i++) {\n            let grandChildEntities = [];\n            for(let i = 1; i <= amount; i++) {\n                grandChildEntities.push({\n                    field: `grandchild ${i}`\n                });\n            }\n\n            childEntities1.push({\n                ID: cds.utils.uuid(),\n                parent_ID: parent_ID,\n                //Calculating values, just to have values for the UI. The generation has no special logic behind it.\n                fieldWithPerCent: (Math.random()+0.1)*100,\n                booleanProperty: (Math.random() > 0.5) ? true : false,\n                criticalityValue_code: (i%2===0) ? 1 : (i%3===0) ? 2 : (i%5===0) ? 3 : 0,\n                field: `child entity ${i}`,\n                grandChildren: grandChildEntities,\n            });\n        }\n        return childEntities1;\n    }\n\n    async function createChildEntities3(amount, parent_ID) {\n        let childEntities3 = [];\n        for(let i = 0; i < amount; i++) {\n            childEntities3.push({\n                ID: cds.utils.uuid(),\n                parent_ID: parent_ID,\n                field: `child entity ${i}`,\n            });\n        }\n        return childEntities3;\n    }\n\n    async function createChartEntities(amount, parent_ID) {\n        let chartEntities = [];\n            for(let i = 1; i <= amount; i++) {\n                chartEntities.push({\n                    ID : cds.utils.uuid(),\n                    parent_ID : parent_ID,\n                    uom_code : 'EA',\n                    dimensions : i,\n                    integerValue : i+30,\n                    forecastValue : i*2+35,\n                    targetValue : i*1.6+36,\n                    criticality_code : i % 4\n                });\n            }\n        console.log(\"Created Chart Data Entities!\");\n        return chartEntities;\n    }\n\n    async function cleanUpDatabaseEntities() {\n        await DELETE.from(RootEntities);\n        await DELETE.from(ChildEntities1);\n        await DELETE.from(ChildEntities2);\n        await DELETE.from(ChildEntities3);\n        await DELETE.from(ChartDataEntities);\n        await DELETE.from(GrandChildEntities);\n    }\n};\n```\n```\n```\n```\n```\n```\n```\n```\n```",
  "excerpt": "service.md javascript service.md javascript service.md javascript service.md javascript service.js",
  "wordCount": 1277,
  "version": "1.0.0",
  "source": "fiori-showcase",
  "sourceType": "github"
}