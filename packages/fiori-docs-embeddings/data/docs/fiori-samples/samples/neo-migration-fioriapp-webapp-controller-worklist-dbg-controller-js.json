{
  "id": "fiori-samples-neo-migration-fioriapp-webapp-controller-worklist-dbg-controller-js",
  "title": "Worklist dbg.controller",
  "category": "samples",
  "path": "neo-migration/fioriapp/webapp/controller/Worklist-dbg.controller.js",
  "lastModified": "2025-09-01T18:17:10.809Z",
  "tags": [
    "samples",
    "js",
    "Worklist",
    "dbg",
    "controller"
  ],
  "headers": [],
  "content": "# Worklist dbg.controller.md\n\n```javascript\n# Worklist dbg.controller.md\n\n```javascript\n# Worklist dbg.controller.md\n\n```javascript\n# Worklist dbg.controller.md\n\n```javascript\n# Worklist dbg.controller.md\n\n```javascript\n# Worklist dbg.controller.md\n\n```javascript\n# Worklist dbg.controller.md\n\n```javascript\n# Worklist dbg.controller.md\n\n```javascript\n# Worklist-dbg.controller.js\n\n```javascript\nsap.ui.define([\n\t\"./BaseController\",\n\t\"sap/ui/model/json/JSONModel\",\n\t\"../model/formatter\",\n\t\"sap/ui/model/Filter\",\n\t\"sap/ui/model/FilterOperator\",\n\t\"sap/m/MessageToast\",\n\t\"sap/m/MessageBox\"\n], function (BaseController, JSONModel, formatter, Filter, FilterOperator, MessageToast, MessageBox) {\n\t\"use strict\";\n\n\treturn BaseController.extend(\"ns.manageproductsneo.controller.Worklist\", {\n\n\t\tformatter: formatter,\n\n\t\t/* =========================================================== */\n\t\t/* lifecycle methods                                           */\n\t\t/* =========================================================== */\n\n\t\t/**\n\t\t * Called when the worklist controller is instantiated.\n\t\t * @public\n\t\t */\n\t\tonInit : function () {\n\t\t\tvar oViewModel,\n\t\t\t\tiOriginalBusyDelay,\n\t\t\t\toTable = this.byId(\"table\");\n\n\t\t\t// Put down worklist table's original value for busy indicator delay,\n\t\t\t// so it can be restored later on. Busy handling on the table is\n\t\t\t// taken care of by the table itself.\n\t\t\tiOriginalBusyDelay = oTable.getBusyIndicatorDelay();\n\t\t\tthis._oTable = oTable;\n\t\t\t// keeps the search state\n\t\t\tthis._aTableSearchState = [];\n\n\t\t\t// Model used to manipulate control states\n\t\t\toViewModel = new JSONModel({\n\t\t\t\tworklistTableTitle: this.getResourceBundle().getText(\"worklistTableTitle\"),\n\t\t\t\tshareOnJamTitle: this.getResourceBundle().getText(\"worklistTitle\"),\n\t\t\t\tshareSendEmailSubject: this.getResourceBundle().getText(\"shareSendEmailWorklistSubject\"),\n\t\t\t\tshareSendEmailMessage: this.getResourceBundle().getText(\"shareSendEmailWorklistMessage\", [location.href]),\n\t\t\t\ttableNoDataText: this.getResourceBundle().getText(\"tableNoDataText\"),\n\t\t\t\ttableBusyDelay: 0,\n\t\t\t\tinStock: 0,\n\t\t\t\tshortage: 0,\n\t\t\t\toutOfStock: 0,\n\t\t\t\tcountAll: 0\n\t\t\t});\n\t\t\tthis.setModel(oViewModel, \"worklistView\");\n\t\t\t// Create an object of filters\n\t\t\tthis._mFilters = {\n\t\t\t\t\"inStock\": [new Filter(\"UnitsInStock\", FilterOperator.GT, 10)],\n\t\t\t\t\"outOfStock\": [new Filter(\"UnitsInStock\", FilterOperator.LE, 0)],\n\t\t\t\t\"shortage\": [new Filter(\"UnitsInStock\", FilterOperator.BT, 1, 10)],\n\t\t\t\t\"all\": []\n\t\t\t};\n\n\t\t\t// Make sure, busy indication is showing immediately so there is no\n\t\t\t// break after the busy indication for loading the view's meta data is\n\t\t\t// ended (see promise 'oWhenMetadataIsLoaded' in AppController)\n\t\t\toTable.attachEventOnce(\"updateFinished\", function(){\n\t\t\t\t// Restore original busy indicator delay for worklist's table\n\t\t\t\toViewModel.setProperty(\"/tableBusyDelay\", iOriginalBusyDelay);\n\t\t\t});\n\t\t},\n\n\t\t/* =========================================================== */\n\t\t/* event handlers                                              */\n\t\t/* =========================================================== */\n\n\t\t/**\n\t\t * Triggered by the table's 'updateFinished' event: after new table\n\t\t * data is available, this handler method updates the table counter.\n\t\t * This should only happen if the update was successful, which is\n\t\t * why this handler is attached to 'updateFinished' and not to the\n\t\t * table's list binding's 'dataReceived' method.\n\t\t * @param {sap.ui.base.Event} oEvent the update finished event\n\t\t * @public\n\t\t */\n\t\tonUpdateFinished : function (oEvent) {\n\t\t\t// update the worklist's object counter after the table update\n\t\t\tvar sTitle,\n\t\t\t\toTable = oEvent.getSource(),\n\t\t\t\toViewModel = this.getModel(\"worklistView\"),\n\t\t\t\tiTotalItems = oEvent.getParameter(\"total\");\n\t\t\t// only update the counter if the length is final and\n\t\t\t// the table is not empty\n\t\t\tif (iTotalItems && oTable.getBinding(\"items\").isLengthFinal()) {\n\t\t\t\tsTitle = this.getResourceBundle().getText(\"worklistTableTitleCount\", [iTotalItems]);\n\t\t\t\t// Get the count for all the products and set the value to 'countAll' property\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function (oData) {\n\t\t\t\t\t\toViewModel.setProperty(\"/countAll\", oData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// read the count for the unitsInStock filter\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function (oData) {\n\t\t\t\t\t\toViewModel.setProperty(\"/inStock\", oData);\n\t\t\t\t\t},\n\t\t\t\t\tfilters: this._mFilters.inStock\n\t\t\t\t});\n\t\t\t\t// read the count for the outOfStock filter\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function(oData){\n\t\t\t\t\t\toViewModel.setProperty(\"/outOfStock\", oData);\n\t\t\t\t\t},\n\t\t\t\t\tfilters: this._mFilters.outOfStock\n\t\t\t\t});\n\t\t\t\t// read the count for the shortage filter\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function(oData){\n\t\t\t\t\t\toViewModel.setProperty(\"/shortage\", oData);\n\t\t\t\t\t},\n\t\t\t\t\tfilters: this._mFilters.shortage\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsTitle = this.getResourceBundle().getText(\"worklistTableTitle\");\n\t\t\t}\n\t\t\tthis.getModel(\"worklistView\").setProperty(\"/worklistTableTitle\", sTitle);\n\t\t},\n\n\t\t/**\n\t\t * Event handler when a table item gets pressed\n\t\t * @param {sap.ui.base.Event} oEvent the table selectionChange event\n\t\t * @public\n\t\t */\n\t\tonPress : function (oEvent) {\n\t\t\t// The source is the list item that got pressed\n\t\t\tthis._showObject(oEvent.getSource());\n\t\t},\n\n\t\t/**\n\t\t * Event handler for navigating back.\n\t\t * We navigate back in the browser history\n\t\t * @public\n\t\t */\n\t\tonNavBack : function() {\n\t\t\thistory.go(-1);\n\t\t},\n\n\n\t\tonSearch : function (oEvent) {\n\t\t\tif (oEvent.getParameters().refreshButtonPressed) {\n\t\t\t\t// Search field's 'refresh' button has been pressed.\n\t\t\t\t// This is visible if you select any master list item.\n\t\t\t\t// In this case no new search is triggered, we only\n\t\t\t\t// refresh the list binding.\n\t\t\t\tthis.onRefresh();\n\t\t\t} else {\n\t\t\t\tvar aTableSearchState = [];\n\t\t\t\tvar sQuery = oEvent.getParameter(\"query\");\n\n\t\t\t\tif (sQuery && sQuery.length > 0) {\n\t\t\t\t\taTableSearchState = [new Filter(\"ProductName\", FilterOperator.Contains, sQuery)];\n\t\t\t\t}\n\t\t\t\tthis._applySearch(aTableSearchState);\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Event handler for refresh event. Keeps filter, sort\n\t\t * and group settings and refreshes the list binding.\n\t\t * @public\n\t\t */\n\t\tonRefresh : function () {\n\t\t\tvar oTable = this.byId(\"table\");\n\t\t\toTable.getBinding(\"items\").refresh();\n\t\t},\n\n\t\t/* =========================================================== */\n\t\t/* internal methods                                            */\n\t\t/* =========================================================== */\n\n\t\t/**\n\t\t * Shows the selected item on the object page\n\t\t * On phones a additional history entry is created\n\t\t * @param {sap.m.ObjectListItem} oItem selected Item\n\t\t * @private\n\t\t */\n\t\t_showObject : function (oItem) {\n\t\t\tthis.getRouter().navTo(\"object\", {\n\t\t\t\tobjectId: oItem.getBindingContext().getProperty(\"ProductID\")\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Internal helper method to apply both filter and search state together on the list binding\n\t\t * @param {sap.ui.model.Filter[]} aTableSearchState An array of filters for the search\n\t\t * @private\n\t\t */\n\t\t_applySearch: function(aTableSearchState) {\n\t\t\tvar oTable = this.byId(\"table\"),\n\t\t\t\toViewModel = this.getModel(\"worklistView\");\n\t\t\toTable.getBinding(\"items\").filter(aTableSearchState, \"Application\");\n\t\t\t// changes the noDataText of the list in case there are no filter results\n\t\t\tif (aTableSearchState.length !== 0) {\n\t\t\t\toViewModel.setProperty(\"/tableNoDataText\", this.getResourceBundle().getText(\"worklistNoDataWithSearchText\"));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Displays an error message dialog. The displayed dialog is content density aware.\n\t\t * @param {string} sMsg The error message to be displayed\n\t\t * @private\n\t\t */\n\t\t_showErrorMessage: function(sMsg) {\n\t\t\tMessageBox.error(sMsg, {\n\t\t\t\tstyleClass: this.getOwnerComponent().getContentDensityClass()\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Event handler when a filter tab gets pressed\n\t\t * @param {sap.ui.base.Event} oEvent the filter tab event\n\t\t * @public\n\t\t */\n\t\tonQuickFilter: function(oEvent) {\n\t\t\tvar oBinding = this._oTable.getBinding(\"items\"),\n\t\t\t\tsKey = oEvent.getParameter(\"selectedKey\");\n\t\t\toBinding.filter(this._mFilters[sKey]);\n\t\t},\n\n\t\t/**\n\t\t * Error and success handler for the unlist action.\n\t\t * @param {string} sProductId the product ID for which this handler is called\n\t\t * @param {boolean} bSuccess true in case of a success handler, else false (for error handler)\n\t\t * @param {number} iRequestNumber the counter which specifies the position of this request\n\t\t * @param {number} iTotalRequests the number of all requests sent\n\t\t * @private\n\t\t */\n\n\t\t_handleUnlistActionResult : function (sProductId, bSuccess, iRequestNumber, iTotalRequests){\n\t\t\t// we could create a counter for successful and one for failed requests\n\t\t\t// however, we just assume that every single request was successful and display a success message once\n\t\t\tif (iRequestNumber === iTotalRequests) {\n\t\t\t\tMessageToast.show(this.getModel(\"i18n\").getResourceBundle().getText(\"StockRemovedSuccessMsg\", [iTotalRequests]));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Error and success handler for the reorder action.\n\t\t * @param {string} sProductId the product ID for which this handler is called\n\t\t * @param {boolean} bSuccess true in case of a success handler, else false (for error handler)\n\t\t * @param {number} iRequestNumber the counter which specifies the position of this request\n\t\t * @param {number} iTotalRequests the number of all requests sent\n\t\t * @private\n\t\t */\n\n\t\t_handleReorderActionResult : function (sProductId, bSuccess, iRequestNumber, iTotalRequests){\n\t\t\t// we could create a counter for successful and one for failed requests\n\t\t\t// however, we just assume that every single request was successful and display a success message once\n\t\t\tif (iRequestNumber === iTotalRequests) {\n\t\t\t\tMessageToast.show(this.getModel(\"i18n\").getResourceBundle().getText(\"StockUpdatedSuccessMsg\", [iTotalRequests]));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Event handler for the unlist button. Will delete the\n\t\t * product from the (local) model.\n\t\t * @public\n\t\t */\n\n\t\tonUnlistObjects: function() {\n\t\t\tvar aSelectedProducts, i, sPath, oProduct, oProductId;\n\n\t\t\taSelectedProducts = this.byId(\"table\").getSelectedItems();\n\t\t\tif (aSelectedProducts.length) {\n\t\t\t\tfor (i = 0; i < aSelectedProducts.length; i++) {\n\t\t\t\t\toProduct = aSelectedProducts[i];\n\t\t\t\t\toProductId = oProduct.getBindingContext().getProperty(\"ProductID\");\n\t\t\t\t\tsPath = oProduct.getBindingContext().getPath();\n\t\t\t\t\tthis.getModel().remove(sPath, {\n\t\t\t\t\t\tsuccess : this._handleUnlistActionResult.bind(this, oProductId, true, i + 1, aSelectedProducts.length),\n\t\t\t\t\t\terror : this._handleUnlistActionResult.bind(this, oProductId, false, i + 1, aSelectedProducts.length)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._showErrorMessage(this.getModel(\"i18n\").getResourceBundle().getText(\"TableSelectProduct\"));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Event handler for the reorder button. Will reorder the\n\t\t * product by updating the (local) model\n\t\t * @public\n\t\t */\n\t\tonUpdateStockObjects: function() {\n\t\t\tvar aSelectedProducts, i, sPath, oProductObject;\n\n\t\t\taSelectedProducts = this.byId(\"table\").getSelectedItems();\n\t\t\tif (aSelectedProducts.length) {\n\t\t\t\tfor (i = 0; i < aSelectedProducts.length; i++) {\n\t\t\t\t\tsPath = aSelectedProducts[i].getBindingContext().getPath();\n\t\t\t\t\toProductObject = aSelectedProducts[i].getBindingContext().getObject();\n\t\t\t\t\toProductObject.UnitsInStock += 10;\n\t\t\t\t\tthis.getModel().update(sPath, oProductObject, {\n\t\t\t\t\t\tsuccess : this._handleReorderActionResult.bind(this, oProductObject.ProductID, true, i + 1, aSelectedProducts.length),\n\t\t\t\t\t\terror : this._handleReorderActionResult.bind(this, oProductObject.ProductID, false, i + 1, aSelectedProducts.length)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._showErrorMessage(this.getModel(\"i18n\").getResourceBundle().getText(\"TableSelectProduct\"));\n\t\t\t}\n\t\t}\n\n\t});\n\n});\n```\n```\n```\n```\n```\n```\n```\n```\n```",
  "excerpt": "Worklist dbg.controller.md javascript Worklist dbg.controller.md javascript Worklist dbg.controller.md javascript Worklist dbg.controller.md javascript Worklist-dbg.controller.js",
  "wordCount": 1213,
  "version": "1.0.0",
  "source": "fiori-samples",
  "sourceType": "github"
}