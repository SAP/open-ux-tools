{
  "id": "sapui5-docs-09-developing-controls-synchronizing-controls-15d74a2-md",
  "title": "Synchronizing Controls",
  "category": "ui5-framework",
  "path": "docs/09_Developing_Controls/synchronizing-controls-15d74a2.md",
  "lastModified": "2025-09-01T18:17:10.684Z",
  "tags": [
    "ui5-framework",
    "md",
    "Synchronizing",
    "Controls"
  ],
  "headers": [
    "Synchronizing Controls",
    "Synchronizing Properties",
    "Synchronizing Aggregations",
    "Synchronizing Events"
  ],
  "content": "<!-- loio15d74a2d274a4d8abc57c5d31fe2deb5 -->\n\n# Synchronizing Controls\n\nHere's how you can keep properties, aggregations, and events synchronized when using the *combine* action.\n\n\n\n<a name=\"loio15d74a2d274a4d8abc57c5d31fe2deb5__section_bqt_4kt_hyb\"/>\n\n## Synchronizing Properties\n\nWhile applying the *combine* change, we sometimes need to create new controls. Like in the previous example, we create a `sap.m.MenuItem` control for each original instance of `sap.m.Button`. The original button can have bindings on certain properties. For example, the `enabled/text/visible` properties can be bound to a custom model. When the bound model changes, the original control reacts accordingly. The same behavior should be inherited by newly created controls \\(in our case `sap.m.MenuItem`\\).\n\n**Example:** If the enabled property changes in the model, the original button receives this change. The newly created `sap.m.MenuItem` control, which corresponds to this button, should also receive this change on the `enabled` property and should disable/enable the new button accordingly.\n\nHere's a solution: The `sap.ui.fl` library provides a special object called `sap.ui.fl.util.ManagedObjectModel`. It's a wrapper of `sap.ui.model.base.ManagedObjectModel`. You can use this object to express the desired synchronization logic between two controls in a declarative way that works on JavaScript and XML level. Here's how:\n\n> ### Sample Code:  \n> Example of `sap.ui.fl.util.ManagedObjectModel` usage for properties synchronization\n> \n> ```\n> // Model name can be any string, but we recommend to use the following pattern to simplify debugging in case of problems:\n> var sModelName = \"$sap.m.flexibility.CombineButtonsModel\";\n>  \n> // Like any other new control, we ask Modifier to create it for us.\n> var oManagedObjectModel = oModifier.createControl(\n>     \"sap.ui.fl.util.ManagedObjectModel\",\n>     oAppComponent,\n>     oView,\n>     Object.assign({}, oSelector, {\n>         id: oSelector.id + '-managedObjectModel' // Make sure this control has a unique ID.\n>     }),\n>     {\n>         object: oButton, // Object against which this model is going to be created.\n>         name: sModelName\n>     }\n> );\n>  \n> // Insert the newly created model into the `dependents` aggregation of the control where this model is going to be used.\n> oModifier.insertAggregation(oMenuItem, \"dependents\", oManagedObjectModel);\n>  \n> // ** IMPORTANT ** DO NOT CALL .setModel() setter on the control, because it cannot be expressed\n> // declaratively on XML level. The setModel() will be called automatically by sap.ui.fl.util.ManagedObjectModel\n> // when it is added to the desired control. That said, after the next line, the oMenuItem already has the model set.\n>  \n> // Create binding against newly created model. The model object automatically subscribes to updates\n> // for the property with the same name in the original object (oButton in this code sample).\n> oModifier.bindProperty(oMenuItem, \"text\", sModelName + \">/text\");\n> ```\n\n> ### Tip:  \n> Find a full example on GitHub at [https://github.com/SAP/openui5/blob/master/src/sap.m/src/sap/m/changeHandler/CombineButtons.js](https://github.com/SAP/openui5/blob/master/src/sap.m/src/sap/m/changeHandler/CombineButtons.js).\n\nThanks to the abstraction of `sap.ui.fl.util.ManagedObjectModel`, we don't have to worry if the original control has bindings or not. This complexity is hidden inside `ManagedObjectModel` itself. `ManagedObjectModel` lets us simply watch properties changes on some control without having to think about implementation details.\n\n\n\n<a name=\"loio15d74a2d274a4d8abc57c5d31fe2deb5__section_kry_c4t_hyb\"/>\n\n## Synchronizing Aggregations\n\nThe original control sometimes has a `customData` aggregation with some data in it, which has to be available from the newly created control as well. In our example: If the `sap.m.Button` has a `customData` aggregation, the same data should be available on `sap.m.MenuItem`, which corresponds to this button.\n\nHere's a solution: By using `sap.ui.fl.util.ManagedObjectModel`, it's also possible to synchronize aggregations. Refer to the previous code snippet on how to create the `ManagedObjectModel` instance. Here's an example on how to bind an aggregation:\n\n> ### Sample Code:  \n> Example of `sap.ui.fl.util.ManagedObjectModel` usage for properties synchronization\n> \n> ```\n> // Create an aggregation binding on customData aggregation on a newly created control (sap.m.MenuItem).\n> oModifier.bindAggregation(oMenuItem, \"customData\", {\n>     path: sModelName + \">/customData\", // Binding path points to the customData property of the model which points to the customData aggregation on the original control.\n>     template: oModifier.createControl( // Template specifies how data should be translated into the receiver control.\n>         \"sap.ui.core.CustomData\",\n>         oAppComponent,\n>         oView,\n>         Object.assign({}, oSelector, { // Make sure the template has a unique ID. The rows in the bound aggregation will use this ID plus postfix - \"-clone-{i}\", where \"i\" is a row number.\n>             id: oSelector.id + '-customData'\n>         }),\n>         {\n>             key: {\n>                 path: sModelName + \">key\" // Binding for `key` property against the CustomData instance on original control\n>             },\n>             value: {\n>                 path: sModelName + \">value\" // Binding for `value` property against the CustomData instance on original control\n>             }\n>         }\n>     )\n> });\n> \n> ```\n\n\n\n<a name=\"loio15d74a2d274a4d8abc57c5d31fe2deb5__section_h3d_1pt_hyb\"/>\n\n## Synchronizing Events\n\nThe original control sometimes has some event handlers attached to it, and these event handlers have to be called. In our example, the original `sap.m.Button` has a press event handler attached. When the newly created control is clicked, the event handler on the original control has to be called as well.\n\nHere's how to do this:\n\n1.  Make sure that the AMD module of the change handler is exported to the global namespace:\n\n    > ### Sample Code:  \n    > Snippet indicating how to expose the AMD module into global namespace\n    > \n    > ```\n    > sap.ui.define(function () {\n    >     \"use strict\";\n    >  \n    >     var CombineButtons = {};\n    >     // Implementation\n    >     return CombineButtons;\n    >  \n    > }, /* bExport= */true); // <<<--- IMPORTANT: Must be `true`.\n    > ```\n\n2.  Create an event handler function inside the change handler. This is called a proxy handler. This proxy function is going to be attached to the newly created control and is responsible to trigger the corresponding event on the original control. Here's an example:\n\n    > ### Sample Code:  \n    > Snippet demonstrating how to define a proxy event handler\n    > \n    > ```\n    > sap.ui.define([\n    >     \"sap/ui/core/util/reflection/JsControlTreeModifier\"\n    > ], function (\n    >     JsControlTreeModifier\n    > ) {\n    >     \"use strict\";\n    >  \n    >     var CombineButtons = {};\n    >  \n    >     /**\n    >      * Callback function which is attached via modifier in applyChange\n    >      * @param {sap.ui.base.Event} oEvent - Event object\n    >      * @param {object} mSelector - Selector object\n    >      * @param {string} mSelector.id - ID used for determination of the flexibility target\n    >      * @param {boolean} mSelector.idIsLocal - Flag if the selector.id has to be concatenated with the application component ID while applying the change.\n    >      */\n    >     CombineButtons.pressHandler = function (oEvent, mSelector) {\n    >         var oButton = JsControlTreeModifier.bySelector(mSelector);\n    >         oButton.firePress(); // The proxy handler is responsible to pass any parameters from oEvent object to firePress() call of the original control.\n    >     };\n    >  \n    >     return CombineButtons;\n    > }, /* bExport= */true);\n    > ```\n\n    > ### Note:  \n    > The proxy function receives the payload object as a second parameter, which contains the information about the original control. It's a standard feature of SAPUI5 that event handlers can receive some payload in addition to a classic `sap.ui.base.Event` object. However, this doesn't happen automatically, the change handler developer needs to bypass this parameter when attaching the event \\(see next step\\).\n\n    > ### Note:  \n    > As no actual events can happen on XML level, it's safe to use `JsControlTreeModifier` inside the proxy event handler. Commonly it's used to get a control instance out of a selector object.\n\n3.  Attach the created proxy handler to newly created control:\n\n    > ### Sample Code:  \n    > Snippet demonstrating how to define a proxy event handler\n    > \n    > ```\n    > oModifier.attachEvent(oMenuItem, \"press\", \"sap.m.changeHandler.CombineButtons.pressHandler\", oModifier.getSelector(oButton, oAppComponent));\n    > \n    > ```\n\n    > ### Note:  \n    > It's important to pass a string that defines a path to the proxy handler. The reason behind it is XML support. For the original control, it's recommended to pass a Selector object.\n\n\n",
  "excerpt": "<!-- loio15d74a2d274a4d8abc57c5d31fe2deb5 --> Synchronizing Controls Here's how you can keep properties, aggregations, and events synchronized when using the combine action. <a name=\"loio15d74a2d274a4...",
  "wordCount": 1242,
  "version": "1.0.0",
  "source": "sapui5",
  "sourceType": "github"
}