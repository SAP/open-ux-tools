{
  "id": "sapui5-docs-03-get-started-step-4-testing-a-new-module-a5bb7a6-md",
  "title": "Step 4: Testing a New Module",
  "category": "ui5-framework",
  "path": "docs/03_Get-Started/step-4-testing-a-new-module-a5bb7a6.md",
  "lastModified": "2025-09-01T18:17:10.475Z",
  "tags": [
    "ui5-framework",
    "md",
    "Step",
    "Testing",
    "New",
    "Module"
  ],
  "headers": [
    "Step 4: Testing a New Module",
    "Preview",
    "Coding",
    "webapp/model/FlaggedType.js \\(new\\)",
    "webapp/test/unit/model/FlaggedType.js \\(new\\)",
    "webapp/test/unit/unitTests.qunit.js",
    "Conventions"
  ],
  "content": "<!-- loioa5bb7a6d736f41c8ac1c1ef0b2d40676 -->\n\n# Step 4: Testing a New Module\n\nIn the first unit test we have just extended the formatters module with a new function. Now we will write a unit test that will test the functionality of an entirely new module.\n\n\n\nA frequently used feature of a bulletin board is to flag interesting posts to mark them for later reading. The UI should contain a button to toggle the flagged state for each item. We will implement this feature with a custom type and again start writing the test case for it first and add the implementation later.\n\n\n\n<a name=\"loioa5bb7a6d736f41c8ac1c1ef0b2d40676__section_hqw_crb_ddc\"/>\n\n## Preview\n\n  \n  \n**The unit test for the Flagged feature will fail until the feature is implemented**\n\n![](images/Tutorial_Testing_Step_04_ba4369b.png \"The unit test for the Flagged feature will fail until the\n\t\t\t\t\tfeature is implemented\")\n\n\n\n## Coding\n\nYou can view and download all files in the *Samples* in the Demo Kit at [Testing - Step 4](https://ui5.sap.com/#/entity/sap.m.tutorial.testing/sample/sap.m.tutorial.testing.04).\n\n\n\n## webapp/model/FlaggedType.js \\(new\\)\n\n```js\nsap.ui.define([\n\t\"sap/ui/model/SimpleType\"\n], function (SimpleType) {\n\t\"use strict\";\n\treturn SimpleType.extend(\"sap.ui.demo.bulletinboard.model.FlaggedType\", {\n\t\tformatValue: function () {\n\t\t},\n\t\tparseValue: function () {\n\t\t},\n\t\tvalidateValue: function () {\n\t\t}\n\t});\n});\n```\n\nWe plan to control a button state based on the `Flagged` property in the model. The button expects a Boolean value for the pressed state. In the model, we have a binary integer representation, so we will again need conversion logic to format the model value. And we also need a back conversion to store a state change in the model when the user clicks the button.\n\nA formatter function will only take care of one direction so this time we decide to implement a custom data type for the conversions. As with the previous test, we add an empty hull for our new data type in the model folder. The `FlaggedType` extends the `SimpleType`. Its interface provides two conversion functions and a validation function:\n\n-   `formatValue`: formats a model value to be displayed in the UI\n\n-   `parseValue`: parses a UI value to be stored in the model\n\n-   `validateValue`: checks a value for displaying validation errors\n\n\n\n\n## webapp/test/unit/model/FlaggedType.js \\(new\\)\n\n```js\n/*global QUnit*/\nsap.ui.define([\n\t\"sap/ui/demo/bulletinboard/model/FlaggedType\"\n], function (FlaggedType) {\n\t\"use strict\";\n\n\tQUnit.module(\"FlaggedType - formatting\");\n\n\tQUnit.test(\"Should convert 1 to true\", function (assert) {\n\t\t// Act\n\t\tvar bFormattedValue = new FlaggedType().formatValue(1);\n\t\t// Assert\n\t\tassert.strictEqual(bFormattedValue , true, \"The formatting conversion was correct\");\n\t});\n\n\tQUnit.test(\"Should convert other values to false\", function (assert) {\n\t\tvar oFlaggedType = new FlaggedType();\n\n\t\t// Act\n\t\tvar bFormattedZero = oFlaggedType.formatValue(0);\n\t\tvar bFormattedNegativeNumber = oFlaggedType.formatValue(-666);\n\t\t// Assert\n\t\tassert.strictEqual(bFormattedZero, false, \"The formatting conversion was correct\");\n\t\tassert.strictEqual(bFormattedNegativeNumber, false, \"The formatting conversion was correct\");\n\t});\n\n\tQUnit.module(\"FlaggedType - parsing\");\n\n\tQUnit.test(\"Should parse false to 0\", function (assert) {\n\t\t// Act\n\t\tvar iParsedValue = new FlaggedType().parseValue(false);\n\t\t// Assert\n\t\tassert.strictEqual(iParsedValue, 0, \"The parsing conversion matched the input\");\n\t});\n\n\tQUnit.test(\"Should parse true to 1\", function (assert) {\n\t\t// Act\n\t\tvar iParsedValue = new FlaggedType().parseValue(true);\n\t\t// Assert\n\t\tassert.strictEqual(iParsedValue, 1, \"The parsing conversion matched the input\");\n\t});\n});\n```\n\nThe new `FlaggedType.js` file matches the file name of the implementation and is put in the `model` subfolder of the `test/unit` folder similar to the implementation under the `webapp` folder. By keeping the same structure for tests and productive code, we can easily relate the tests to the implementation.\n\nWe load the new and still empty `FlaggedType` implementation as the only dependency and declare two QUnit modules: one for formatting and one for parsing, to check both the to- and back-conversion of the flagged type.\n\n> ### Note:  \n> We do not test the validation function of the data type as our conversion is so simple. There are no expected validation errors that we have to take care of.\n\nIn each QUnit module we define test cases for each condition. For a Boolean conversion there are just two cases, `true` and `false`. So we expect that the integer value `1` is converted to `true` and everything else to `false`.\n\nLet's have a look at the first test case to see how the custom data type is invoked for testing.\n\nAs we have loaded the type as a dependency, we can just access it with the variable `FlaggedType` and create a new instance of it in each test case. This time we do not create a `reuse` function but simply create the instance inside the test case. On the type we manually call the function `formatValue` that we want to test and compare the result to the expected value in an assertion.\n\nIn the second test case, we check all other values, we expect it to be `0` but it could be also a negative value. So we check both cases in the same test case with a separate assertion each. Only when both assertions are fulfilled the test will be successful.\n\nThe other test cases in the parsing module are similar and check the back conversion from Boolean value to integer value.\n\n\n\n## webapp/test/unit/unitTests.qunit.js\n\n```js\nsap.ui.define([\n\t\"./model/models\",\n\t\"./model/formatter\",\n\t\"./model/FlaggedType\"\n]);\n```\n\nIn the `unitTests.qunit.js` file we just load the new testing module as a dependency so that it is executed automatically whenever we execute the unit tests.\n\nYou can now call the unit tests and check the result. As in the previous step, the tests should fail with an error message that the conversion is not correct. This is expected as we did not implement the conversion logic yet but just the tests for it.\n\n\n\n## Conventions\n\n-   Use data types if you need both formatting and parsing of a model value\n\n-   Organize the tests in the same file structure as the productive code\n\n\n**Related Information**  \n\n\n[API Reference: `sap.ui.model.SimpleType`](https://ui5.sap.com/#/api/sap.ui.model.SimpleType)\n\n[API Reference: `sap.ui.define`](https://ui5.sap.com/#/api/sap.ui/methods/sap.ui.define)\n\n[Formatting, Parsing, and Validating Data](../04_Essentials/formatting-parsing-and-validating-data-07e4b92.md \"Data that is presented on the UI often has to be converted so that is human readable and fits to the locale of the user. On the other hand, data entered by the user has to be parsed and validated to be understood by the data source. For this purpose, you use formatters and data types.\")\n\n",
  "excerpt": "<!-- loioa5bb7a6d736f41c8ac1c1ef0b2d40676 --> Step 4: Testing a New Module In the first unit test we have just extended the formatters module with a new function. Now we will write a unit test that wi...",
  "wordCount": 991,
  "version": "1.0.0",
  "source": "sapui5",
  "sourceType": "github"
}