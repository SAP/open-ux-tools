{
  "id": "sapui5-docs-04-essentials-odata-operations-b54f789-md",
  "title": "OData Operations",
  "category": "ui5-framework",
  "path": "docs/04_Essentials/odata-operations-b54f789.md",
  "lastModified": "2025-09-01T18:17:10.531Z",
  "tags": [
    "ui5-framework",
    "md",
    "OData",
    "Operations"
  ],
  "headers": [
    "OData Operations",
    "Simple Function Bindings",
    "Deferred Operation Bindings",
    "Action Bindings",
    "Operation Parameters",
    "Bound Actions and Functions",
    "Addressing properties of an entity via an operation's binding parameter",
    "Strict Handling",
    "Advertised Operations",
    "Access Operation Results"
  ],
  "content": "<!-- loiob54f7895b7594c61a83fa7257fa9d13f -->\n\n# OData Operations\n\nThe OData V4 model supports OData operations \\(`ActionImport`, `FunctionImport`, bound `Actions` and bound `Functions`\\). Unbound parameters are limited to primitive values.\n\n\n\n## Simple Function Bindings\n\nYou gain access to a `FunctionImport` by binding it to a view element. If there are no parameters and there is no need to control the point in time when the function is called, you can simply bind the OData path like this:\n\n```\n<Text \n    core:require=\"{\n        Int16: 'sap/ui/model/odata/type/Int16'\n    }\"\n    text=\"{\n        path: '/GetNumberOfAvailableItems()',\n        type: 'Int16'\n    }\" />\n```\n\nThis binding path represents the function's return value. The model calls the function immediately when a control requests this value.\n\nThe type must be specified if the return value is a primitive type.\n\n\n\n## Deferred Operation Bindings\n\nOften it is not feasible for the operation to be called immediately, for example if there are parameters that the user has to enter first. In such cases, use an ODataContextBinding as element binding at a layout element in the view, for example a `<Form>` or a `<VBox>` \\(see the [ODataContextBinding](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataContextBinding) API documentation in the Demo Kit\\). Mark the operation as **deferred** by inserting an ellipsis \\(\"...\"\\) in the brackets, for example `GetNextAvailableItem(...)`. Access the return value from child elements using relative bindings. When used like this, the context binding is called an **operation binding** or more specifically, a **function binding** or **action binding** depending on the type of OData operation it is used for.\n\nIf the operation binding defers operation invocation, you need to call its `invoke` method to invoke the operation. See below for an example.\n\n**View:**\n\n```xml\n<Form id=\"getNextAvailableItem\" binding=\"{/GetNextAvailableItem(...)}\">\n    <Label text=\"Description\"/>\n    <Text text=\"{Description}\"/>\n    <Button text=\"Call the function\" press=\"onGetNextAvailableItem\"/>\n</Form>\n```\n\n**Controller:**\n\n```js\nonGetNextAvailableItem : function (oEvent) {\n    this.getView().byId(\"getNextAvailableItem\").getObjectBinding().invoke();\n}\n```\n\nIn the above example, the form \\(which has an ID that we need later\\) is bound to the context of the operation binding. The text field showing a property of the result is a child of this form. It has a relative binding to the property `\"Description\"`.\n\nIf the function returns a primitive value or a collection, the binding for the result must be `\"{value}\"` as shown in the two examples below:\n\n**View:**\n\n```xml\n<Form id=\"getNumberOfAvailableItems\" binding=\"{/GetNumberOfAvailableItems(...)}\">\n    <Label text=\"Number of available items:\"/>\n    <Text text=\"{value}\"/>\n    <Button text=\"Call the function\" press=\"onGetNumberOfAvailableItems\"/>\n</Form>\n```\n\n```\n<VBox id=\"getAvailableItems\" binding=\"{path : '/GetAvailableItems(...)', parameters : {$select : ['ProductName', 'ProductId']}}\">\n    <List id=\"xyz\" items=\"{value}\">\n        <items>\n            <ObjectListItem title=\"{ProductName}\" />\n        </items>\n    </List>\n</VBox>\n```\n\n`invoke` returns a promise which is resolved if the operation was successful and rejected with an error if this was not the case. Note that the promise is **not** fulfilled with the action's result: Use dependent bindings to access the result.\n\n`refresh` is silently ignored on a deferred function binding as long as it has not yet been invoked. Afterwards, a `refresh` calls the function again.\n\n\n\n## Action Bindings\n\nAction bindings must be deferred, otherwise the application cannot control when the action is invoked. A deferred action binding is declared exactly like a deferred function binding:\n\n**View:**\n\n```xml\n<Form id=\"Submit\" binding=\"{/Submit(...)}\">\n    <Button text=\"Submit the action\" press=\"onSubmit\"/>\n</Form>\n```\n\nYou append \"\\(...\\)\" even though the action's resource URL does not contain them. However, they are needed to mark the binding as deferred. In `invoke`, the binding uses the metadata to distinguish between action and function and to build the correct operation resource path.\n\n`refresh` is always silently ignored on a deferred action binding to prevent the action from being invoked accidentally \\(for example by calling the `refresh` method on the ODataModel instance `oModel.refresh()`\\).\n\n\n\n## Operation Parameters\n\nYou can use the parameters of a deferred operation binding inside an XML view.\n\nThe parameters are addressed by the path prefix \"$Parameter\". This can either be done by binding each control property via the path prefix \"$Parameter\" \\(Option 1\\) or by having an outer binding with a \"$Parameter\" path \\(Option 2\\).\n\n> ### Note:  \n> The path \"$Parameter\" must not be added directly to the path of a deferred operation binding. A deferred operation binding is identified by an ellipsis at the end of the path.\n\nThis is how to bind each property without a \"$Parameter\" context:\n\n**View:**\n\n> ### Example:  \n> Binding parameters to a dialog \\(Option 1\\)\n> \n> ```xml\n> <Dialog binding=\"{/ChangeTeamBudgetByID(...)}\" id=\"operation1\" title =\"Change Team Budget\">\n>     <buttons>\n>         ...         \n>     </buttons>\n>     <form:SimpleForm>\n>         <Label text=\"TeamID\" />\n>         <Input value=\"{$Parameter/TeamID}\" />\n>         <Label text=\"Budget\" />\n>         <Input value=\"{$Parameter/Budget}\" />\n>     </form:SimpleForm>\n> </Dialog>\n> ```\n\nAlternatively, you may bind the entire form to the `$Parameter` context:\n\n**View:**\n\n> ### Example:  \n> Binding parameters to a dialog \\(Option 2\\)\n> \n> ```xml\n> <Dialog binding=\"{/ChangeTeamBudgetByID(...)}\" id=\"operation2\" title=\"Change Team Budget\">\n>     <buttons>\n>         ...         \n>     </buttons>\n>     <form:SimpleForm binding=\"{$Parameter}\">\n>         <Label text=\"TeamID\" />\n>         <Input value=\"{TeamID}\" />\n>         <Label text=\"Budget\" />\n>         <Input value=\"{Budget}\" />\n>     </form:SimpleForm>\n> </Dialog>\n> ```\n\nIn either case, the values of the parameters are set using the context binding of the control, with no need to write any application code.\n\nAlternatively, operation parameters can be set by calling the function `setParameter` on the operation binding, as shown in this example:\n\n**Controller:**\n\n```js\nonSubmit : function (oEvent) {\n    this.getView().byId(\"Submit\").getObjectBinding().setParameter(\"Comment\", sComment).invoke();\n}\n```\n\nThe API method `getParameterContext` can be used to access parameters in controller code, see also [Accessing Data in Controller Code](accessing-data-in-controller-code-17b30ac.md)\n\nThe example below demonstrates how a budget may be modified depending on the `TeamID`:\n\n**Controller:**\n\n> ### Example:  \n> Reading parameter values using the parameter context\n> \n> ```js\n> adaptBudgetToTeam : function (){\n>     var oDialog = this.oView.byId(\"operation2\"); // the second dialog in the paragraph before\n>         oParameterContext = oDialog.getObjectBinding().getParameterContext();\n>  \n>  \n>     if (oParameterContext.getProperty(\"TeamID\") === \"STARTUP\") {\n>         oParameterContext.setProperty(\"Budget\", 555.55);\n>     else {\n>         oParameterContext.setProperty(\"Budget\", 123.45);\n>     }\n> }\n> ```\n\n> ### Note:  \n> The parameter context is only defined if the operation binding is resolved.\n\n\n\n<a name=\"loiob54f7895b7594c61a83fa7257fa9d13f__section_BAAF\"/>\n\n## Bound Actions and Functions\n\nSo far, the examples always used operations at root level, addressed via an action import or function import. However, it is also possible to bind an action or a function to another resource of the service. This can be an entity or a collection of entities.\n\nBound actions or functions are controlled in the same way as unbound operations; append `(...)` to the binding path for the control's property.\n\nTo call actions or functions bound to a single entity or navigation property, use a relative binding. The following sample calls the \"invoice created\" action on the sales order selected in the corresponding table:\n\n```js\nvar oModel = this.getView().getModel(),\n    oTable = this.getView().byId(\"SalesOrders\"),\n    oSalesOrderContext = oTable.getSelectedItem().getBindingContext(),\n    oAction = oModel.bindContext(\"name.space.InvoiceCreated(...)\", oSalesOrderContext);\n \noAction.invoke().then(\n    function () {\n        MessageToast.show(\"Invoice created for sales order \" + oSalesOrderContext.getProperty(\"SalesOrderID\"));\n    },\n    function (oError) {\n        MessageBox.alert(oError.message, {\n            icon : MessageBox.Icon.ERROR,\n            title : \"Error\"});\n        });\n    }\n);\n```\n\nTo call actions or functions bound to a collection specified by an OData entity set, you can create a context binding with an absolute path, or with a relative path for the operation \\(for example `name.space.DestroyOutdated(...)\"`\\) and the header context of a list binding as parent context. The following sample shows a button press event handler which calls the `destroy outdated` action on the `LeaveRequests` entity set.\n\n```js\nvar oModel = this.getView().getModel();\n \noModel.bindContext(\"/LeaveRequests/name.space.DestroyOutdated(...)\").invoke();\n```\n\nThe same example with a relative binding and the header context of the list binding as parent context:\n\n```js\nvar oModel = this.getView().getModel(),\n    // assume there is a table with ID \"leaveRequests\" and its items aggregation bound to \"/LeaveRequests\"\n    oListBinding = this.byId(\"leaveRequests\").getBinding(\"items\"),\n    oHeaderContext = oListBinding.getHeaderContext();\n\noModel.bindContext(\"name.space.DestroyOutdated(...)\", oHeaderContext).invoke(); \n```\n\n> ### Note:  \n> -   The path of an operation binding may also start with a navigation property.\n> \n>     Example: The operation binding has a relative path `BP_2_PRODUCT/name.space.Change(...)`. You set its binding context from the selected item in a table bound to `/BusinessPartners`. When you call `invoke` on the operation binding, the \"change\" action is invoked with the selected business partner's navigation property `BP_2_PRODUCT` as binding parameter.\n> \n> -   The parent binding of a deferred operation must not be a deferred operation itself.\n> \n> -   When invoking a bound action, you can use the `bIgnoreETag` argument of [`ODataContextBinding#invoke`](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataContextBinding/methods/invoke) to actively ignore the ETag match that normally happens \\(technically, the header *\"If-Match : \\*\"* will be used\\). This is useful if a second bound action for the same entity is to be invoked within the same batch \\(especially if it is in a different change set\\). An example would be \"prepare\" and \"activate\" for draft handling. Without this, the second bound action would be rejected, because the client sent the initial ETag via the *\"If-Match\"* header, but the first bound action changes that ETag on the server before the second one is invoked.\n\n\n\n### Addressing properties of an entity via an operation's binding parameter\n\nFor operations bound to an entity, it is possible to address properties of the entity through the operation's binding parameter.\n\nFor example, let `CreateInvoice` be a bound action on the `SalesOrder` entity type with the binding parameter `_it`. Properties of the current sales order can be addressed with a property binding having a path that starts with the binding parameter name `_it`.\n\n> ### Example:  \n> Addressing properties of the binding parameter\n> \n> ```xml\n> \n> <Dialog binding=\"{name.space.CreateInvoice(...)}\" id=\"operation\" title=\"Address Note property of the sales order\">\n>     <form:SimpleForm binding=\"{$Parameter}\">\n>         <Label text=\"Note\" />\n>         <Input value=\"{_it/Note}\" />\n>     </form:SimpleForm>\n> </Dialog>\n> ```\n\n\n\n<a name=\"loiob54f7895b7594c61a83fa7257fa9d13f__section_SH\"/>\n\n## Strict Handling\n\nIn some cases an action should not be performed in case warnings are present, unless the user explicitly confirms the action. To this end, the HTTP request header `Prefer:handling=strict` is used to request the server to handle warnings like errors. In the case of an action, this means that the request will only be successful if there are no warnings. In case the request fails, the user is prompted to decide whether the action is aborted, allowing the user to fix the warnings, or continued by ignoring the warnings.\n\nThe strict handling is requested by the client with the HTTP request header `Prefer:handling=strict`. The server replies with HTTP status code `412 Precondition Failed` and the response header `Preference-Applied:handling=strict` if the request fails because the preference was applied.\n\nTo request this behavior, you have to provide `fnOnStrictHandlingFailed` as a callback function when invoking [`sap.ui.model.odata.v4.ODataContextBinding#invoke`](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataContextBinding/methods/invoke) . This callback is called if the action is rejected with HTTP status code `412 Precondition Failed` and the response header `Preference-Applied:handling=strict`. All relevant messages of the OData error are passed to the callback as an array of [`sap.ui.core.message.Message`](https://ui5.sap.com/#/api/sap.ui.core.message.Message) . These messages are not reported to the message model. The callback may be used to visualize the messages and has to return a `Promise` resolving with a `boolean` value. If this `Promise` resolves with `true`, the bound action is repeated, now without requesting `Prefer:handling=strict`. Otherwise, the `Promise` returned by `sap.ui.model.odata.v4.ODataContextBinding#invoke` will be canceled.\n\nIt is possible to include multiple actions in the same change set, for example when invoking an action on multiple items in a list. If one or more of the actions is rejected with HTTP status code `412 Precondition Failed` and the response header `Preference-Applied:handling=strict`, **all** of the actions included in the change set are rejected. The `fnOnStrictHandlingFailed` callback will then be invoked for all rejected actions; each callback instance only recieves the relevant messages for its associated action. This means that it's possible that no messages will be given to some of the callbacks.\n\nTo enable strict handling for the above example, the controller code snippet may look like this:\n\n> ### Example:  \n> \"`Prefer:handling=strict`\"\n> \n> ```xml\n> // XML view:\n> // the messages may be visualized in a sap.m.Dialog via sap.m.MessageView and sap.m.MessageItem like this\n>     <Dialog id=\"onStrictMessagesDialog\"\n>             title=\"Messages during order confirmation, do you want to continue?\"\n>             resizable=\"true\" contentHeight=\"50%\" contentWidth=\"50%\"\n>             verticalScrolling=\"false\" state=\"Warning\">\n>         <buttons>\n>             <Button id=\"confirmStrictMode\" text=\"Yes\"\n>                     tooltip=\"Ignore warnings and confirm anyhow\"\n>                 press=\"onConfirmStrictMessages\"/>\n>             <Button id=\"cancelStrictMode\" text=\"No\"\n>                     tooltip=\"Cancel confirmation\"\n>                 press=\"onCancelStrictMessages\" type=\"Emphasized\"/>\n>         </buttons>\n>         <MessageView items=\"{ui>/strictMessages}\">\n>             <MessageItem\n>                 type=\"{ui>type}\"\n>                 title=\"{ui>message}\"\n>                 subtitle=\"{ui>target}\">\n>             </MessageItem>\n>         </MessageView>\n>     </Dialog>\n>  \n> // controller code:\n> // event handler that invokes the bound action\n> onInvokeAction : function () {\n>   var that = this;\n>  \n> ...\n>  \n>     function onStrictHandlingFailed (aMessages) {\n>         var oView = that.oView;\n>  \n>         oView.getModel(\"ui\").setProperty(\"/strictMessages\", aMessages);\n>         oView.byId(\"onStrictMessagesDialog\").open();\n>             return new Promise(function (fnResolve) {\n>                 that.fnStrictResolve = fnResolve;\n>             });\n>         }\n>     }\n>  \n>     oAction.invoke(undefined, undefined, onStrictHandlingFailed).then(\n>       function () {\n>         MessageToast.show(\"Invoice created for sales order\");\n>       },\n>       function (oError) {\n>         if (!oError.canceled)\n>           MessageBox.alert(oError.message, {icon : MessageBox.Icon.ERROR, title : \"Error\"});\n>       });\n> });\n>  \n> // event handler to confirm the message and repeat the action\n> onConfirmStrictMessages : function () {\n>     this.fnStrictResolve(true);\n>     this.oView.byId(\"onStrictMessagesDialog\").close();\n> },\n>  \n> // event handler to reject the action\n> onCancelStrictMessages : function () {\n>     this.fnStrictResolve(false);\n>     this.oView.byId(\"onStrictMessagesDialog\").close();\n> },\n> ```\n\nSee also the example in the Demo Kit: [Controller Code for `sap.ui.core.sample.odata.v4.SalesOrders.onConfirmSalesOrder`](https://ui5.sap.com/#/entity/sap.ui.model.odata.v4.ODataModel/sample/sap.ui.core.sample.odata.v4.SalesOrders/code/Main.controller.js)\n\n\n\n<a name=\"loiob54f7895b7594c61a83fa7257fa9d13f__section_osx_m5l_gdb\"/>\n\n## Advertised Operations\n\nAccording to the [OData 4.0 specification \\(\"11.5.2 Advertising Available Operations within a Payload\"\\)](http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part1-protocol/odata-v4.0-errata03-os-part1-protocol-complete.html#_Toc453752309) services may return available actions and functions bound to a particular entity as part of the entity representation within the payload. Data for an advertised operation within an entity is sent as property starting with `#<namespace>.<action>` of that entity. If the entity does not advertise the operation, it does not contain this property. To access the advertised operation in a binding, the same format has to be used. See the following example:\n\n> ### Example:  \n> Enable a button to initiate an action `AcSetIsOccupied` available on entity type of entity set `EMPLOYEES` depending on advertisement of this action on the entity `EMPLOYEES('1')`\n\n```\n<FlexBox binding=\"{/EMPLOYEES('1')}\">\n    <Button text=\"Set occupied\" enabled=\"{= !!%{#com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsOccupied} }\"/>\n</FlexBox>\n```\n\nHere a button is enabled only if the action `AcSetIsOccupied` is advertised for the entity `EMPLOYEES('1')`. The `%` operator is used to set the internal type to `any` because the advertised action is sent as an object. The double negation `!!` converts this object to a boolean value that is needed by the `enabled` control property.\n\nIf no advertised action was returned in the payload, `undefined` \\(or `null` in OData 4.01 in case of advertised non-availability\\) is returned as value for the binding. This translates to false in the expression above.\n\nIf there is an additional list of non-binding parameter names to identify a specific overload, then they need to be given in the binding path as well, for instance: `%{#Model.RemainingVacation(Year)}`.\n\n> ### Note:  \n> The bound action advertisement is added to $select automatically if the model parameter [`autoExpandSelect`](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataModel/constructor) is set.\n\nTo access the metadata of an operation, the double hash \\(`##`\\) syntax has to be used as is illustrated in the next example:\n\n> ### Example:  \n> Binding against metadata of an action\n> \n> ```\n> var oContext = oModel.createBindingContext(\"/EMPLOYEES('1')/##com.sap.gateway.default.iwbep.tea_busi.v0001.AcSetIsOccupied\");\n> var oMetaModel = oContext.getModel();\n> oMetaModel.requestObject(\"0/$ReturnType/$Type\", oContext).then(alert);\n> ```\n\nHere a context is created pointing to the metadata of the action and afterwards the type is accessed using this context.\n\nThis approach can also be used with XML templating where [`createBindingContext`](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataModel/methods/createBindingContext) is called internally.\n\n\n\n<a name=\"loiob54f7895b7594c61a83fa7257fa9d13f__section_AOR\"/>\n\n## Access Operation Results\n\nYou can access the results of the operation by calling `getObject()` from the bound context.\n\n```js\n// let oOperation be the operation's context binding\noOperation.invoke().then(function () {\n    // Note: invoke does not deliver the results\n\n    var oResults = oOperation.getBoundContext().getObject();\n    ...\n});\n```\n\nThe promise returned by the operation binding's [`invoke`](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataContextBinding/methods/invoke) method may resolve with a *return value context* provided the conditions specified in [`invoke`](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataContextBinding/methods/invoke) are met. The operation binding may be bound to an entity or a collection of entities.\n\nThe typical use case for *return value context* is when you call a bound operation with a `C1` context defining its binding parameter and the bound operation returns a *different version* of the entity used as binding parameter. `C1` is the binding context of an \"object page\" container displaying properties of the corresponding entity. You need to replace `C1` as binding context of the object page by the*return value context*. This way, the *different version* of the entity is displayed without a further read request. If the bound operation returns the entity used as binding parameter, the changes will automatically be copied to the binding parameter.\n\nIf the operation binding fulfills the conditions for returning a context, you can set the `$$inheritExpandSelect` parameter for the binding: The request for the bound operation is then sent with the same `$expand` and `$select` query options used to load the operation's binding parameter. This way you guarantee that all fields of the object page are available in the operation response.\n\nIf the `C1` context belongs to a list binding, for example in a list report, you can pass the `bReplaceWithRVC` flag to the operation binding's `invoke` method in order to immediately replace `C1` in the list with the return value context and return that list context instead. This way, the *different version* of the entity is displayed even inside the list report without a further read request. For more information, see [`sap.ui.model.odata.v4.ODataContextBinding#invoke`](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataContextBinding/methods/invoke) and [Draft Handling with the OData V4 Model](draft-handling-with-the-odata-v4-model-40986e6.md).\n\nSample object page to display an `Artist` entity\n\n```\n<form:SimpleForm id=\"objectPage\">\n    <Toolbar>\n        <Button text=\"Edit\" enabled=\"{IsActiveEntity}\" press=\".onEdit\"/>\n    </Toolbar>\n    <Label text=\"ID\"/> <Text text=\"{ArtistID}\"/>\n    <Label text=\"Is Active\"/> <Text text=\"{IsActiveEntity}\"/>\n    <Label text=\"Name\"/> <Input value=\"{Name}\" />\n    ...\n</form:SimpleForm>\n```\n\nController code to display the active version of `Artist 42` initially and switch to draft version on *Edit*\n\n```\n// display \"active\" version of artist initially\nonInit : function () {\n    var oActiveArtistContext = oModel\n        \t.bindContext(\"/Artists(ArtistID='42',IsActiveEntity=true)\")\n        \t.getBoundContext();\n    this.byId(\"objectPage\").setBindingContext(oActiveArtistContext);\n},\n \n// display the \"inactive\" version of the entity returned by the \"EditAction\"\nonEdit : function () {\n    var that = this;\n    oModel.bindContext(\"name.space.EditAction(...)\", this.byId(\"objectPage\").getBindingContext(), {$$inheritExpandSelect : true})\n        .invoke()\n        .then(function (oInactiveArtistContext) {\n            that.byId(\"objectPage\").setBindingContext(oInactiveArtistContext);\n        });\n}\n```\n\n**Related Information**  \n\n\n[OData Version 4.0 Part 1, 11.5 Operations](http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part1-protocol.html)\n\n[ODataContextBinding](https://ui5.sap.com/#/api/sap.ui.model.odata.v4.ODataContextBinding)\n\n",
  "excerpt": "<!-- loiob54f7895b7594c61a83fa7257fa9d13f --> OData Operations The OData V4 model supports OData operations \\(ActionImport, FunctionImport, bound Actions and bound Functions\\). Unbound parameters are ...",
  "wordCount": 2963,
  "version": "1.0.0",
  "source": "sapui5",
  "sourceType": "github"
}