{
  "id": "sapui5-docs-04-essentials-cookbook-for-testing-controls-with-qunit-0ddcc60-md",
  "title": "Cookbook for Testing Controls with QUnit",
  "category": "ui5-framework",
  "path": "docs/04_Essentials/cookbook-for-testing-controls-with-qunit-0ddcc60.md",
  "lastModified": "2025-09-01T18:17:10.501Z",
  "tags": [
    "ui5-framework",
    "md",
    "Cookbook",
    "for",
    "Testing",
    "Controls",
    "with",
    "QUnit"
  ],
  "headers": [
    "Cookbook for Testing Controls with QUnit",
    "Test Cases",
    "Testing User Interactions",
    "Rendering and Re-rendering Controls within Tests",
    "Testing with Server-Side Models",
    "Testing for a Theme Change"
  ],
  "content": "<!-- loio0ddcc60b05ee40dea1a3be09e8fee8f7 -->\n\n# Cookbook for Testing Controls with QUnit\n\n\n\n## Test Cases\n\nYou can use a factory function. To keep this pointer and have a descriptive message, you should use the test inside of the function and pass a test name to it.\n\nInternally, we prefer to pass an object to the test for retrieving the values - it makes the test cases readable.\n\n```js\n// \"Bar\" required from module \"sap/m/Bar\"\n// \"nextUIUpdate\" required from module \"sap/ui/test/utils/nextUIUpdate\"\nfunction renderBarInPageTestCase(sTestName, oOptions) {\n    QUnit.test(sTestName, async(assert) => { \n        // System under Test\n        const oBar = new Bar();\n\n        oBar.placeAt(\"qunit-fixture\");\n\n        // Act\n        oBar.applyTagAndContextClassFor(oOptions.context);\n\n        await nextUIUpdate();\n\n        // Assert\n       assert.strictEqual(oBar.getDomRef().nodeName, oOptions.expectedTag.toUpperCase());\n       assert.ok(oBar.$().hasClass(oOptions.expectedClass), \"The bar has the context class: \" + oOptions.expectedClass);\n\n        // Cleanup\n        oBar.destroy();\n    });\n};\n\nrenderBarInPageTestCase(\"Should render the header context\", {\n    context : \"header\",\n    expectedTag : \"header\",\n    expectedClass : \"sapMHeader-CTX\"\n});\n\nrenderBarInPageTestCase(\"Should render the header context\", {\n    context : \"subheader\",\n    expectedTag : \"header\",\n    expectedClass : \"sapMSubHeader-CTX\"\n});\n\nrenderBarInPageTestCase(\"Should render the header context\", {\n    context : \"footer\",\n    expectedTag : \"footer\",\n    expectedClass : \"sapMFooter-CTX\"\n});\n```\n\n\n\n## Testing User Interactions\n\nWhen testing user interactions, you can use `sap.ui.test.qunit` to trigger events.\n\nHere is an example for when a user presses [Esc\\] on the select:\n\n```js\n// \"Item\" required from module \"sap/ui/core/Item\"\n// \"Select\" required from module \"sap/m/Select\"\n// \"KeyCodes\" required from module \"sap/ui/events/KeyCodes\"\n// \"nextUIUpdate\" required from module \"sap/ui/test/utils/nextUIUpdate\"\n// \"QUnitUtils\" required from module \"sap/ui/qunit/QUnitUtils\"\nQUnit.test(\"Should close the popup menu if it is open and you press escape\", async(assert) => {\n    // Arrange\n    const oConstructor = {\n        items: [\n        new Item({\n            key: \"0\",\n            text: \"item 0\"\n        }),\n\n        new Item({\n            key: \"1\",\n            text: \"item 1\"\n        })\n       ]\n    };\n\n    // System under test\n    const oSelect = new Select(oConstructor);\n\n    oSelect.placeAt(\"select-content\");\n    await nextUIUpdate();\n\n    // Arrange after rendering\n    oSelect.focus();\n    const fnEscapeSpy = this.spy(oSelect, \"onsapescape\");\n    const fnCloseSpy = this.spy(oSelect, \"close\");\n\n    // Act\n    QUnitUtils.triggerKeydown(oSelect.getDomRef(), KeyCodes.ESCAPE);\n\n    // Assertion\n    assert.strictEqual(fnEscapeSpy.callCount, 1, \"onsapescape() method was called exactly once\");\n    assert.strictEqual(fnCloseSpy.callCount, 0, \"close() method is not called\");\n\n    // Cleanup\n    oSelect.destroy();\n});\n```\n\n\n\n<a name=\"loio0ddcc60b05ee40dea1a3be09e8fee8f7__section_REREN\"/>\n\n## Rendering and Re-rendering Controls within Tests\n\nIn the rendering tests part, you have to place your control in the DOM. The best place to put it is the `qunit-fixture` div, since its content gets deleted after every test.\n\nMake sure you destroy your control, since SAPUI5 will keep a reference to it and may also rerender it.\n\nIt's crucial that you wait for the Promise of `sap/ui/test/utils/nextUIUpdate` after each time you've caused a rerendering.\n\nExecuting the module returns a Promise which resolves after rendering. If you don't wait for the Promise, the DOM won't be updated yet.\n\nYou can use the following template to make sure that you remember to destroy your control:\n\n```js\n// \"nextUIUpdate\" required from module \"sap/ui/test/utils/nextUIUpdate\"\nQUnit.test(\"Should do Something\", async(assert) => {\n    // Arrange\n    const oConstructor = {\n\n    };\n\n    // System under Test\n    const oMyControl = new nameSpace.myControl(oConstructor);\n    oMyControl.placeAt(\"qunit-fixture\");\n\n    // Wait for the rendering before proceeding the test\n    await nextUIUpdate();\n\n    // Act\n\n    // Assert\n\n    // Cleanup\n    oMyControl.destroy();\n});\n```\n\n> ### Caution:  \n> Using `nextUIUpdate` in combination with fake timers has some pitfalls. If fake timers are used, you need to pass the `clock` of the fake timer to the `nextUIUpdate` function call.\n> \n> When working with a fake timer, keep in mind to either execute all timeouts before restoring the fake timer or to make sure that no rendering is pending. Not executing the pending timeouts can lead to issues within the following tests, for example by interupting the rendering lifecycle.\n\nExample usage of `nextUIUpdate` in combination with a fake timer:\n\n```js\n// nextUIUpdate with fake timer\nQUnit.test(\"Test with fake timers\", async() => {\n    this.clock = sinon.useFakeTimers();\n\n    // Coding which requires rendering, e.g.\n    const oButton = new Button();\n    oButton.placeAt(\"qunit-fixture\");\n\n    await nextUIUpdate(this.clock);\n\n    // Continue with your test\n\n    // Release all timers at the end of the test\n    // to avoid e.g. blocking the rendering within\n    // following tests and to ensure that other\n    // timeouts triggered through integration are\n    // released\n    oButton.destroy()\n    this.clock.runAll();\n    this.clock.restore();\n}\n```\n\nIn the example below, you will test to see whether the control fails to rerender. The control has overwritten the setter of the tooltip property to avoid triggering a re-rendering.\n\nTo test this, we add an `eventDelegate` to see how often the rendering function is called. We need to make sure that we wait for the next rendering:\n\n```js\n// \"Label\" required from module \"sap/m/Label\"\n// \"nextUIUpdate\" required from module \"sap/ui/test/utils/nextUIUpdate\"\nQUnit.test(\"Should suppress rerendering when tooltip is set\", async(assert) => { \n    // Arrange\n    const oConstructor = {\n        tooltip : \"foo\"\n        };\n    const oRerenderingSpy = this.spy();\n\n    // System under Test\n    const oLabel = new Label(oConstructor);\n    oLabel.placeAt(\"qunit-fixture\");\n\n    // wait for rendering\n    await nextUIUpdate();\n\n    oLabel.addEventDelegate({\n        onBeforeRendering : oRerenderingSpy\n    });\n\n    // Act\n    oLabel.setTooltip(\"bar\");\n\n   // wait for rendering\n    await nextUIUpdate();\n\n    // Assert\n    assert.strictEqual(oRerenderingSpy.callCount, 0, \"Did not rerender\");\n    assert.strictEqual(oLabel.getTooltip(), \"bar\", \"Tooltip property got set\");\n    assert.strictEqual(oLabel.$().attr(\"title\"), \"bar\", \"Tooltip got updated\");\n\n    // Cleanup\n    oLabel.destroy();\n});\n```\n\n\n\n## Testing with Server-Side Models\n\nFor bindable properties of your control, it should be possible to bind them to server-side models, i.e. models for which not all data is available on the client but is loaded asynchronously from a server. This is especially important for more complex controls, e.g. with an aggregation which may be bound to a collection loaded using paging. A typical example for server-side models are UI5's OData models. When testing with models, you need to make sure that you also set up/destroy the model itself inside your test. In the following, we will show an example using the OData V2 mock server:\n\n```js\n\n// \"MockServer\" required from module \"sap/ui/core/util/MockServer\"\n\nfunction startMockServer(iRespondAfter) {\n    // configure respond to requests delay\n    MockServer.config({\n        autoRespond : true,\n        autoRespondAfter : iRespondAfter || 10\n    });\n\n    // create mockserver\n    const oMockServer = new MockServer({\n        rootUri : \"http://sap.com/service/\"\n    });\n\n    // start and return\n    oMockServer.simulate(\"data/metadata.xml\", \"data\");\n    oMockServer.start();\n    return oMockServer;\n}\n\n//Your test:\nQUnit.test(\"Should do something with the model\", function (assert) {\n    //Arrange\n    const oMockServer = startMockServer(0);\n    \n    // System under Test + Act\n\n    //Cleanup\n    oMockServer.stop();\n});\n```\n\nWhen using the OData V2 mock server, you can use async tests since calling respond each time on the mock server does not help the readability of the test.\n\nAfter setting up the OData V2 mock server, we set up the model as follows:\n\n```js\n\n// \"ODataModel\" required from module \"sap/ui/model/odata/v2/ODataModel\"\n// \"jQuery\" required from module \"sap/ui/thirdparty/jquery\"\n\nfunction createODataModel(sURL, mSettings) {\n    sURL = sURL || \"http://sap.com/service/\";\n    const oModel = new ODataModel(sURL);\n    \n    mSettings = mSettings || {};\n    jQuery.each(mSettings, function(sProperty, vValue) {\n        sProperty = sProperty[0].toUpperCase() + sProperty.substring(1);\n        oModel[\"set\" + sProperty](vValue);\n    });\n    \n    return oModel;\n}\n\n//Your test:\nQUnit.test(\"Should do something with the model\", function(assert) {\n    // Arrange\n    const oModel = createODataModel();\n    const oMockServer = startMockServer(0);\n    const done = assert.async();\n\n    // System under Test + Act + call done();\n\n    // Cleanup\n    oModel.destroy();\n    oMockServer.stop();\n});\n```\n\nYou can now bind your model against your control and test whatever you want.\n\nWe use `clock.tick` to trigger the server response. If you didn't do this, the text of the label would still be empty:\n\n```js\n// \"Label\" required from module \"sap/m/Label\"\n// \"nextUIUpdate\" required from module \"sap/ui/test/utils/nextUIUpdate\"\n\n//Your test:\nQUnit.test(\"Should do something with the model\", async(assert) => {\n    // Arrange\n    const oModel = createODataModel();\n    const oMockServer = startMockServer(50);\n\n    // System under Test\n    const oLabel = new Label({\n        text : \"{/myProperty}\"\n    });\n\n    oLabel.placeAt(\"qunit-fixture\");\n    await nextUIUpdate();\n\n    // Act - trigger the request\n    sinon.clock.tick(50);\n\n    // Assert\n    assert.strictEqual(\"myExpected\", oLabel.getText(), \"The expected text was present\");\n\n    // Cleanup\n    oModel.destroy();\n    oMockServer.stop();\n    sinon.clock.reset() \n});\n```\n\n\n\n<a name=\"loio0ddcc60b05ee40dea1a3be09e8fee8f7__section_ljv_b3r_rzb\"/>\n\n## Testing for a Theme Change\n\n```js\nsap.ui.require([\"sap/ui/core/Theming\"], (Theming) => {\n    QUnit.test(\"Check if theme change was done correctly\", function(assert){\n        const myTestFunction = () => {\n            // Test changes are applied\n            Theming.detachApplied(myTestFunction);\n        }\n        Theming.setTheme(\"myTestTheme\");\n        Theming.attachApplied(myTestFunction);\n    });\n});\n```\n\n",
  "excerpt": "<!-- loio0ddcc60b05ee40dea1a3be09e8fee8f7 --> Cookbook for Testing Controls with QUnit Test Cases You can use a factory function. To keep this pointer and have a descriptive message, you should use th...",
  "wordCount": 1265,
  "version": "1.0.0",
  "source": "sapui5",
  "sourceType": "github"
}