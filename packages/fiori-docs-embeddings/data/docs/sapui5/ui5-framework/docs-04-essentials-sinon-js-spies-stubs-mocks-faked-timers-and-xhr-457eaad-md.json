{
  "id": "sapui5-docs-04-essentials-sinon-js-spies-stubs-mocks-faked-timers-and-xhr-457eaad-md",
  "title": "Sinon.JS: Spies, Stubs, Mocks, Faked Timers, and XHR",
  "category": "ui5-framework",
  "path": "docs/04_Essentials/sinon-js-spies-stubs-mocks-faked-timers-and-xhr-457eaad.md",
  "lastModified": "2025-09-01T18:17:10.544Z",
  "tags": [
    "ui5-framework",
    "md",
    "Sinon",
    "Spies",
    "Stubs",
    "Mocks",
    "Faked",
    "Timers",
    "and",
    "XHR"
  ],
  "headers": [
    "Sinon.JS: Spies, Stubs, Mocks, Faked Timers, and XHR",
    "Spies",
    "Stubs",
    "Mocks",
    "Faked Timers",
    "Faked XHR"
  ],
  "content": "<!-- loio457eaada68a24187858fd5e8b21a4892 -->\n\n# Sinon.JS: Spies, Stubs, Mocks, Faked Timers, and XHR\n\nBy integrating Sinon.JS for QUnit, you can use spies, stubs, mocks, faked timers or faked XHR. For more information about using sinon.js, see the official documentation at `http://sinonjs.org/docs/`.\n\nAll you have to do is add a sinon section to the test suite configuration as shown below:\n\n```js\nsap.ui.define(function() {\n\t\"use strict\";\n \n\treturn {\n\t\tname: \"TestSuite for myapp\",\n\t\tdefaults: {\n\t\t\tqunit: {\n\t\t\t\tversion: 2\n\t\t\t},\n\t\t\tsinon: {\n\t\t\t\tversion: 4,\n\t\t\t\tqunitBridge: true,\n\t\t\t\tuseFakeTimers: false\n\t\t\t}\n\t\t},\n\n\t\t// ...\n\n\t};\n});\n```\n\nThe variable `sinon` is now globally available in your test.\n\nThe following examples show you the basic way in which Sinon.JS can be used. These examples are adapted from the official Sinon.JS documentation available at `http://sinonjs.org/docs/`:\n\n\n\n<a name=\"loio457eaada68a24187858fd5e8b21a4892__section_wn1_n3q_f1c\"/>\n\n## Spies\n\nA simple spy test:\n\n```js\n/*global QUnit sinon */\nsap.ui.define([\"sap/m/Button\"], function(Button) {\n\t \"use strict\";\n\n\t QUnit.test(\"Spy\", 2, function(assert) {\n\n\t \tvar callback = sinon.spy();\n\t \tvar oButton = new Button();\n\t \toButton.attachPress(callback);\n\t \tassert.ok(!callback.called, \"Callback Spy not called yet\");\n\t \toButton.firePress();\n\t \tassert.ok(callback.called, \"Callback Spy called\");\n\t \toButton.destroy();\n\n\t });\n});\n```\n\n\n\n<a name=\"loio457eaada68a24187858fd5e8b21a4892__section_bxx_43q_f1c\"/>\n\n## Stubs\n\nA simple stub test:\n\n```js\n/*global QUnit sinon */\nsap.ui.define([], function() {\n \t\"use strict\";\n \n \tQUnit.test(\"Stub\", 1, function(assert) {\n \t\tsinon.stub(jQuery, \"ajax\").yieldsTo(\"success\", [1, 2, 3]);\n \n \t\tjQuery.ajax({\n \t\t\tsuccess: function (data) {\n \t\t\t\tassert.deepEqual(data, [1, 2, 3], \"Right data set\"); \n \t\t\t}\n \t\t});\n \t\tjQuery.ajax.restore();\n \t});\n})\n```\n\n\n\n<a name=\"loio457eaada68a24187858fd5e8b21a4892__section_mbs_q3q_f1c\"/>\n\n## Mocks\n\nA simple mock test:\n\n```js\n/*global QUnit sinon */\nsap.ui.define([], function() {\n\t \"use strict\";\n\n \tQUnit.test(\"Mock\", 2, function(assert) {\n \t\tvar myAPI = { method: function () {} };\n \n \t\tvar mock = sinon.mock(myAPI);\n\t\tmock.expects(\"method\").once().throws();\n \n \t\ttry {\n \t\t\tmyAPI.method();\n \t\t} catch (exc) {\n \t\t\tassert.ok(mock.verify(), \"Mock function called and all expectations are fullfilled\");\n \t\t}\n \t\tmock.restore();\n \t});\n});\n```\n\n\n\n<a name=\"loio457eaada68a24187858fd5e8b21a4892__section_FAKETIM\"/>\n\n## Faked Timers\n\nA simple faked timer test:\n\n```js\n/*global QUnit sinon */\nsap.ui.define([], function() {\n \t\"use strict\";\n\n \n \tQUnit.test(\"Basic\", 1, function(assert) {\n \t\tvar oClock = sinon.useFakeTimers();\n \t\tsetTimeout(function() {\n \t\t\tassert.ok(true, \"Called without need of async test\");\n \t\t}, 800);\n \t\toClock.tick(800);\n \t\toClock.restore();\n \t});\n});\n```\n\nIf you use `sinon.qunit`, it will automatically use fake timers by itself. Fake timers will prevent any `setTimeout/setInterval` function from being executed, unless you call `this.clock.tick(milliseconds)` in your test. This means that a mock server with auto-respond won't respond, and OPA won't be able to wait for controls.\n\nIn addition, control events might be fired inside a `setTimeout(, 0)`, so the event might not be triggered at all.\n\nIn general, fake timers should only be used if needed in specific test scenarios.\n\n> ### Note:  \n> Be aware that `sinon` v4 and below does not provide a mock for all stubbed performance APIs, e.g. `Performance.getEntriesByType` or properties such as `Performance.timeOrigin`. In case the code under test relies on these APIs, you need to provide them.\n> \n> Keep in mind that fake timers affect each usage of `setTimeout`, `clearTimeout`, `setInterval`, `clearInterval`, `setImmediate`, `clearImmediate`, `process.hrtime`, `performance.now` \\(when available\\), and `Date`, also the ones **not** under your control, e.g triggered by the SAPUI5 framework.\n> \n> Before restoring the fake timers, you should always execute any possibly pending callbacks via `clock.runAll()`.\n\n```js\nQUnit.test(\"Test with fake timers\", assert() => {\n    // Setup fake timer\n    const timeOrigin = performance.timeOrigin;\n    const clock = sinon.useFakeTimers();\n    // Mock performance API in case it's used by the code under test\n    performance.getEntriesByType = function() {\n        return [];\n    };\n    performance.timeOrigin = timeOrigin;\n\n    ...\n\n    // Cleanup\n    delete performance.getEntriesByType;\n    delete performance.timeOrigin;\n    // Execute all pending timer callbacks\n    this.clock.runAll();\n    this.clock.restore();\n});\n```\n\n\n\n<a name=\"loio457eaada68a24187858fd5e8b21a4892__section_mfx_g3q_f1c\"/>\n\n## Faked XHR\n\nA simple faked XHR test:\n\n```js\n/*global QUnit sinon */\nsap.ui.define([], function() {\n\t\"use strict\";\n\n\tQUnit.module(\"Faked XHR\", {\n\t\tbeforeEach: function() {\n\t\t\tthis.xhr = sinon.useFakeXMLHttpRequest();\n\t\t\tvar requests = this.requests = [];\n\n\t\t\tthis.xhr.onCreate = function (xhr) {\n\t\t\t\trequests.push(xhr);\n\t\t\t};\n\t\t},\n\n\t\tafterEach: function() {\n\t\t\tthis.xhr.restore();\n\t\t}\n\t});\n\n\tQUnit.test(\"Basic\", 2, function(assert) {\n\t\tvar callback = sinon.spy();\n\n\t\tjQuery.ajax(\"test\", {\n\t\t\tsuccess: callback\n\t\t});\n\n\t\tassert.equal(1, this.requests.length, \"Right number of requests\");\n\n\t\tthis.requests[0].respond(200, {\n\t\t\t\"Content-Type\": \"application/json\"\n\t\t}, '[{ \"foo\": \"bar\", \"bar\" : \"foo\" }]');\n\t\tassert.ok(callback.calledWith([{ \"foo\": \"bar\", \"bar\" : \"foo\" }]), \"Data is called right\");\n\t});\n```\n\n",
  "excerpt": "<!-- loio457eaada68a24187858fd5e8b21a4892 --> Sinon.JS: Spies, Stubs, Mocks, Faked Timers, and XHR By integrating Sinon.JS for QUnit, you can use spies, stubs, mocks, faked timers or faked XHR. For mo...",
  "wordCount": 653,
  "version": "1.0.0",
  "source": "sapui5",
  "sourceType": "github"
}