{
  "id": "sapui5-docs-03-get-started-step-22-custom-formatters-typescript-61d4e2b-md",
  "title": "Step 22: Custom Formatters \\(TypeScript\\)",
  "category": "ui5-framework",
  "path": "docs/03_Get-Started/step-22-custom-formatters-typescript-61d4e2b.md",
  "lastModified": "2025-09-01T18:17:10.463Z",
  "tags": [
    "ui5-framework",
    "md",
    "Step",
    "Custom",
    "Formatters",
    "TypeScript"
  ],
  "headers": [
    "Step 22: Custom Formatters \\(TypeScript\\)",
    "Preview",
    "Coding",
    "webapp/i18n/i18n.properties",
    "webapp/model/formatter.ts \\(New\\)",
    "webapp/view/InvoiceList.view.xml"
  ],
  "content": "<!-- loio61d4e2b154a7449da198577dfbc75a22 -->\n\n# Step 22: Custom Formatters \\(TypeScript\\)\n\nIf we want to do a more complex logic for formatting properties of our data model, we can also write a custom formatting function. We will now add a localized status with a custom formatter, because the status in our data model is in a rather technical format.\n\n\n\n## Preview\n\n  \n  \n**A status is now displayed with a custom formatter**\n\n![A list of invoices is displayed below the panel](images/UI5_Walkthrough_Step_22_7aa185a.png \"A status is now displayed with a custom formatter\")\n\n\n\n<a name=\"loio61d4e2b154a7449da198577dfbc75a22__section_lp1_2nk_syb\"/>\n\n## Coding\n\nYou can view all files at [OpenUI5 TypeScript Walkthrough - Step 22: Custom Formatters](https://github.com/sap-samples/ui5-typescript-walkthrough/tree/main/steps/22) and [download the solution as a zip file](https://sap-samples.github.io/ui5-typescript-walkthrough/ui5-typescript-walkthrough-step-22.zip).\n\n\n\n<a name=\"loio61d4e2b154a7449da198577dfbc75a22__section_sxs_4kz_nzb\"/>\n\n## webapp/i18n/i18n.properties\n\nWe add three new entries to the resource bundle that reflect our translated status texts 'New', 'In Progess', and 'Done'. We will use these texts to format the status values 'A', 'B', and 'C' of our invoices when displayed in the invoice list view.\n\n```ini\n\n...\n\n# Invoice List\ninvoiceListTitle=Invoices\ninvoiceStatusA=New\ninvoiceStatusB=In Progress\ninvoiceStatusC=Done\n```\n\n\n\n<a name=\"loio61d4e2b154a7449da198577dfbc75a22__section_mp1_2nk_syb\"/>\n\n## webapp/model/formatter.ts \\(New\\)\n\nWe place a new `formatter.ts` file in the model folder of the app, This time we do not need to extend from any base object, but just return an object with our `formatter` functions in it. We add a `statusText` function that gets a status as input parameter and returns a human-readable text that is read from the `resourceBundle` file.\n\n```js\nimport ResourceBundle from \"sap/base/i18n/ResourceBundle\";\nimport Controller from \"sap/ui/core/mvc/Controller\";\nimport ResourceModel from \"sap/ui/model/resource/ResourceModel\";\n\nexport default  {\n    statusText: function (this: Controller, status: string): string | undefined {\n        const resourceBundle = (this?.getOwnerComponent()?.getModel(\"i18n\") as ResourceModel)?.getResourceBundle() as ResourceBundle;\n        switch (status) {\n            case \"A\":\n                return resourceBundle.getText(\"invoiceStatusA\");\n            case \"B\":\n                return resourceBundle.getText(\"invoiceStatusB\");\n            case \"C\":\n                return resourceBundle.getText(\"invoiceStatusC\");\n            default:\n                return status;\n        }\n    }\n};\n```\n\nThe new `formatter.ts` file is placed in the `model` folder of the app, because formatters are working on data properties and format them for display on the UI.\n\n> ### Note:  \n> In the above example, `this` refers to the controller instance as soon as the formatter gets called. We access the resource bundle via the component using `this.getOwnerComponent().getModel()` instead of using `this.getView().getModel()`. The latter call might return `undefined`, because the view might not have been attached to the component yet, and thus the view can't inherit a model from the component.\n\n**Additional Information:**\n\n-   [API Reference: `sap.ui.core.mvc.Controller#getOwnerComponent`](https://ui5.sap.com/#/api/sap.ui.core.mvc.Controller/methods/getOwnerComponent). \n-   [API Reference: `sap.ui.core.mvc.Controller#onInit`](https://ui5.sap.com/#/api/sap.ui.core.mvc.Controller/methods/onInit). \n\n\n\n## webapp/view/InvoiceList.view.xml\n\nTo load our formatter functions, we use the [`require`](../04_Essentials/require-modules-in-xml-view-and-fragment-b11d853.md) attribute with the `sap.ui.core` namespace URI, for which the `core` prefix is already defined in our XML view. This allows us to write the attribute as `core:require`. We then add our custom formatter module to the list of required modules and assign it the `Formatter` alias, making it available for use within the view.\n\nWe add a status using the `firstStatus` aggregation to our `ObjectListItem` that will display the status of our invoice. The custom formatter function is specified with the reserved `formatter` property of the binding syntax. There, we use our `Formatter` alias that holds our formatter functions in order to access the desired function via `Formatter.statusText`. When called, we want the `this` context to be set to the current view controller's context. To achieve this, we use [`.bind($controller)`](../04_Essentials/formatting-parsing-and-validating-data-07e4b92.md).\n\n```xml\n<mvc:View\n    controllerName=\"ui5.walkthrough.controller.InvoiceList\"\n    xmlns=\"sap.m\"\n    xmlns:core=\"sap.ui.core\"\n    xmlns:mvc=\"sap.ui.core.mvc\">\n    <List\n        headerText=\"{i18n>invoiceListTitle}\"\n        class=\"sapUiResponsiveMargin\"\n        width=\"auto\"\n        items=\"{invoice>/Invoices}\">\n        <items>\n            <ObjectListItem\n                core:require=\"{\n                    Currency: 'sap/ui/model/type/Currency'\n                }\"\n                title=\"{invoice>Quantity} x {invoice>ProductName}\"\n                number=\"{\n                    parts: [\n                        'invoice>ExtendedPrice',\n                        'view>/currency'\n                    ],\n                    type: 'Currency',\n                    formatOptions: {\n                        showMeasure: false\n                    }\n                }\"\n                numberUnit=\"{view>/currency}\"\n                numberState=\"{= ${invoice>ExtendedPrice} > 50 ? 'Error' : 'Success' }\">\n                <firstStatus>\n                    <ObjectStatus\n                        core:require=\"{\n                            Formatter: 'ui5/walkthrough/model/formatter'\n                        }\"\n                        text=\"{\n                            path: 'invoice>Status',\n                            formatter: 'Formatter.statusText.bind($controller)'\n                        }\"/>\n                </firstStatus>\n            </ObjectListItem>\n        </items>\n    </List>\n</mvc:View>\n```\n\nInstead of a technical status we get now the human-readable texts below the `number` attribute of the `ObjectListItem` that we specified in our resource bundle.\n\n**Related Information**  \n\n\n[Formatting, Parsing, and Validating Data](../04_Essentials/formatting-parsing-and-validating-data-07e4b92.md \"Data that is presented on the UI often has to be converted so that is human readable and fits to the locale of the user. On the other hand, data entered by the user has to be parsed and validated to be understood by the data source. For this purpose, you use formatters and data types.\")\n\n",
  "excerpt": "<!-- loio61d4e2b154a7449da198577dfbc75a22 --> Step 22: Custom Formatters \\(TypeScript\\) If we want to do a more complex logic for formatting properties of our data model, we can also write a custom fo...",
  "wordCount": 686,
  "version": "1.0.0",
  "source": "sapui5",
  "sourceType": "github"
}