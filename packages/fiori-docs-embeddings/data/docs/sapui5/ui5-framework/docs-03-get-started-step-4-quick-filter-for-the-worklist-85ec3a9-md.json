{
  "id": "sapui5-docs-03-get-started-step-4-quick-filter-for-the-worklist-85ec3a9-md",
  "title": "Step 4: Quick Filter for the Worklist",
  "category": "ui5-framework",
  "path": "docs/03_Get-Started/step-4-quick-filter-for-the-worklist-85ec3a9.md",
  "lastModified": "2025-09-01T18:17:10.475Z",
  "tags": [
    "ui5-framework",
    "md",
    "Step",
    "Quick",
    "Filter",
    "for",
    "the",
    "Worklist"
  ],
  "headers": [
    "Step 4: Quick Filter for the Worklist",
    "Preview",
    "Coding",
    "webapp/view/Worklist.view.xml \\[MODIFY\\]",
    "webapp/controller/Worklist.controller.js \\[MODIFY\\]",
    "webapp/controller/Worklist.controller.js \\[MODIFY\\]",
    "webapp/controller/Worklist.controller.js \\[MODIFY\\]",
    "webapp/i18n/i18n.properties \\[MODIFY\\]"
  ],
  "content": "<!-- loio85ec3a9454ac4eb1a901745e773844d3 -->\n\n# Step 4: Quick Filter for the Worklist\n\nFor easily detecting and managing product shortages in our app, we will add a quick filter for the worklist table. Users can press the filter tabs to display the products according to whether they are in stock, have low stock or no stock. The table will update accordingly and show only the products matching the criteria.\n\n\n\n## Preview\n\n  \n  \n**A quick filter allows filtering the product table**\n\n![](images/Tutorial_Worklist_Step_4_Preview_395f8ac.png \"A quick filter allows filtering the product table\")\n\n\n\n## Coding\n\nYou can view and download all files in the Demo Kit at [Worklist App - Step 4](https://ui5.sap.com/#/entity/sap.m.tutorial.worklist/sample/sap.m.tutorial.worklist.04).\n\n\n\n### webapp/view/Worklist.view.xml \\[MODIFY\\]\n\n```xml\n<mvc:View\n\tcontrollerName=\"mycompany.myapp.MyWorklistApp.controller.Worklist\"\n\txmlns:mvc=\"sap.ui.core.mvc\"\n\txmlns:semantic=\"sap.f.semantic\">\n\n\t<semantic:SemanticPage\n\t\tid=\"page\"\n\t\theaderPinnable=\"false\"\n\t\ttoggleHeaderOnTitleClick=\"false\">\n\n\t\t<semantic:titleHeading>\n\t\t\t<Title text=\"{i18n>worklistTitle}\" />\n\t\t</semantic:titleHeading>\n\n\t\t<semantic:headerContent>\n\t\t\t<IconTabBar\n\t\t\t\tid=\"iconTabBar\"\n\t\t\t\tselect=\".onQuickFilter\"\n\t\t\t\texpandable=\"false\">\n\t\t\t\t<items>\n\t\t\t\t\t<IconTabFilter\n\t\t\t\t\t\tkey=\"all\"\n\t\t\t\t\t\tshowAll=\"true\"\n\t\t\t\t\t\tcount=\"{worklistView>/countAll}\"\n\t\t\t\t\t\ttext=\"{i18n>WorklistFilterProductsAll}\"/>\n\t\t\t\t\t<IconTabSeparator/>\n\t\t\t\t\t<IconTabFilter\n\t\t\t\t\t\tkey=\"inStock\"\n\t\t\t\t\t\ticon=\"sap-icon://message-success\"\n\t\t\t\t\t\ticonColor=\"Positive\"\n\t\t\t\t\t\tcount=\"{worklistView>/inStock}\"\n\t\t\t\t\t\ttext=\"{i18n>WorklistFilterInStock}\"/>\n\t\t\t\t\t<IconTabFilter\n\t\t\t\t\t\tkey=\"shortage\"\n\t\t\t\t\t\ticon=\"sap-icon://message-warning\"\n\t\t\t\t\t\ticonColor=\"Critical\"\n\t\t\t\t\t\tcount=\"{worklistView>/shortage}\"\n\t\t\t\t\t\ttext=\"{i18n>WorklistFilterShortage}\"/>\n\t\t\t\t\t<IconTabFilter\n\t\t\t\t\t\tkey=\"outOfStock\"\n\t\t\t\t\t\ticon=\"sap-icon://message-error\"\n\t\t\t\t\t\ticonColor=\"Negative\"\n\t\t\t\t\t\tcount=\"{worklistView>/outOfStock}\"\n\t\t\t\t\t\ttext=\"{i18n>WorklistFilterOutOfStock}\"/>\n\t\t\t\t</items>\n\t\t\t\t<content>\n\t\t\t\t\t<Table\n...\n\t\t\t\t\t</Table>\n\t\t\t\t</content>\n\t\t\t</IconTabBar>\n\n\n\t\t</semantic:headerContent>\n\t\t<semantic:sendEmailAction>\n\t\t\t<semantic:SendEmailAction\n\t\t\t\tid=\"shareEmail\"\n\t\t\t\tpress=\"onShareEmailPress\"/>\n\t\t</semantic:sendEmailAction>\n\t</semantic:SemanticPage>\n</mvc:View>\n\n```\n\nWe now update the view and add the new UI for the quick filter to the content aggregation of the `sap.m.SemanticPage` control just before the `table`. It is modeled using a `sap.m.IconTabBar` control and a `sap.m.IconTabFilter` for each of the following filter options:\n\n-   *Total Stock*\n\n    This tab will simply show the overall number of products that has been returned by the data service. The `count` property is bound to a local view model and the number will be updated in the controller later in this step. This tab will show a larger number only \\(optional\\) and no icon by using the `showAll` property.\n\n-   *Out of Stock*\n\n    This tab will show all the products that are out of stock. We choose a matching icon from the icon font and set the icon color to the semantic `Negative` state so that it will appear in red.\n\n-   *Shortage*\n\n    This tab will show products that have less than 10 pieces remaining with a semantic `Critical` state that will make the icon appear in orange. The count of the number of low stock products will be displayed on the tab and the icon will appear in orange.\n\n-   *Plenty in Stock*\n\n    This tab will show products that have more than 10 pieces in stock. The semantic `Positive` state will let the icon appear in green. As usual the UI texts for the tabs are linked to the resource bundle file and will be added later. Do not forget to set the standard CSS class `sapUiNoMarginTop` on the table to remove the spacing between the `IconTabBar` and the `table` and make the UI look nicer.\n\n    > ### Note:  \n    > Each `IconTabFilter` element has a `key` property that is used to identify the tab that was pressed in the event handler `onQuickFilter` that is registered on the `IconTabBar` control directly. The event handler implementation does the actual filtering on the table and is defined in the controller.\n\n\n\n\n### webapp/controller/Worklist.controller.js \\[MODIFY\\]\n\n```js\n\t\t...\n\t\tonInit : function () {\n\t\t\tvar oViewModel,\n\t\t\t\tiOriginalBusyDelay,\n\t\t\t\toTable = this.byId(\"table\");\n\n\t\t\t// Put down worklist table's original value for busy indicator delay,\n\t\t\t// so it can be restored later on. Busy handling on the table is\n\t\t\t// taken care of by the table itself.\n\t\t\tiOriginalBusyDelay = oTable.getBusyIndicatorDelay();\n\t\t\tthis._oTable = oTable;\n\t\t\t// keeps the search state\n\t\t\tthis._aTableSearchState = [];\n\n\t\t\t// Model used to manipulate control states\n\t\t\toViewModel = new JSONModel({\n\t\t\t\tworklistTableTitle: this.getResourceBundle().getText(\"worklistTableTitle\"),\n\t\t\t\tshareOnJamTitle: this.getResourceBundle().getText(\"worklistTitle\"),\n\t\t\t\tshareSendEmailSubject: this.getResourceBundle().getText(\"shareSendEmailWorklistSubject\"),\n\t\t\t\tshareSendEmailMessage: this.getResourceBundle().getText(\"shareSendEmailWorklistMessage\", [location.href]),\n\t\t\t\ttableNoDataText: this.getResourceBundle().getText(\"tableNoDataText\"),\n\t\t\t\ttableBusyDelay: 0,\n\t\t\t\tinStock: 0,\n\t\t\t\tshortage: 0,\n\t\t\t\toutOfStock: 0,\n\t\t\t\tcountAll: 0\n\t\t\t});\n\t\t\tthis.setModel(oViewModel, \"worklistView\");\n\t\t\t// Create an object of filters\n\t\t\tthis._mFilters = {\n\t\t\t\t\"inStock\": [new Filter(\"UnitsInStock\", FilterOperator.GT, 10)],\n\t\t\t\t\"outOfStock\": [new Filter(\"UnitsInStock\", FilterOperator.LE, 0)],\n\t\t\t\t\"shortage\": [new Filter(\"UnitsInStock\", FilterOperator.BT, 1, 10)],\n\t\t\t\t\"all\": []\n\t\t\t};\n\n\t\t\t// Make sure, busy indication is showing immediately so there is no\n\t\t\t// break after the busy indication for loading the view's meta data is\n\t\t\t// ended (see promise 'oWhenMetadataIsLoaded' in AppController)\n\t\t\toTable.attachEventOnce(\"updateFinished\", function(){\n\t\t\t\t// Restore original busy indicator delay for worklist's table\n\t\t\t\toViewModel.setProperty(\"/tableBusyDelay\", iOriginalBusyDelay);\n\t\t\t});\n\t\t},\n\t\t...\n```\n\nAs a preparation step for the filter tabs we add properties for the counters into the local view model of the worklist controller. We initialize the four values with `0` each. Furthermore, we create an object `_mFilters` that contains a filter for each tab. We will use the filters for filtering the table below the tabs. The properties in `_mFilters` correlate to the keys of the `IconTabFilter` controls we defined above in the `Worklist.view.xml` file. This way we can easily access a filter for a given tab based on the key of the corresponding tab.\n\nCreating a simple filter requires a binding path as first parameter of the filter constructor \\(e.g. `\"UnitsInStock\"`\\), a filter operator \\(e.g. `\"GT\"`\\) as second argument, and a value to compare \\(e.g. `10`\\) as the third argument. We create such filters for all three tabs with different filter operators as described in the view part above. Additionally, we create an `all` filter, which is an empty array for clearing the binding again \\(when the user chooses the *All* tab\\).\n\n\n\n### webapp/controller/Worklist.controller.js \\[MODIFY\\]\n\n```js\n\t\t...\n\t\tonUpdateFinished : function (oEvent) {\n\t\t\t// update the worklist's object counter after the table update\n\t\t\tvar sTitle,\n\t\t\t\toTable = oEvent.getSource(),\n\t\t\t\toViewModel = this.getModel(\"worklistView\"),\n\n\t\t\t\tiTotalItems = oEvent.getParameter(\"total\");\n\t\t\t// only update the counter if the length is final and\n\t\t\t// the table is not empty\n\t\t\tif (iTotalItems && oTable.getBinding(\"items\").isLengthFinal()) {\n\t\t\t\tsTitle = this.getResourceBundle().getText(\"worklistTableTitleCount\", [iTotalItems]);\n\t\t\t\t// Get the count for all the products and set the value to 'countAll' property\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function (oData) {\n\t\t\t\t\t\toViewModel.setProperty(\"/countAll\", oData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// read the count for the unitsInStock filter\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function (oData) {\n\t\t\t\t\t\toViewModel.setProperty(\"/inStock\", oData);\n\t\t\t\t\t},\n\t\t\t\t\tfilters: this._mFilters.inStock\n\t\t\t\t});\n\t\t\t\t// read the count for the outOfStock filter\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function(oData){\n\t\t\t\t\t\toViewModel.setProperty(\"/outOfStock\", oData);\n\t\t\t\t\t},\n\t\t\t\t\tfilters: this._mFilters.outOfStock\n\t\t\t\t});\n\t\t\t\t// read the count for the shortage filter\n\t\t\t\tthis.getModel().read(\"/Products/$count\", {\n\t\t\t\t\tsuccess: function(oData){\n\t\t\t\t\t\toViewModel.setProperty(\"/shortage\", oData);\n\t\t\t\t\t},\n\t\t\t\t\tfilters: this._mFilters.shortage\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\tsTitle = this.getResourceBundle().getText(\"worklistTableTitle\");\n\t\t\t}\n\t\t\tthis.getModel(\"worklistView\").setProperty(\"/worklistTableTitle\", sTitle);\n\t\t},\n\t\t...\n```\n\nIn the `onUpdateFinished` function, we get the count of all products by triggering a read operation on the model with the appropriate filter. The filter is a helper object of SAPUI5 that defines the condition for each tab on the data binding level. We already created the filters in the `onInit` function.\n\n> ### Note:  \n> The `v2.ODataModel` will automatically bundle these `read` requests to one batch request to the server \\(if batch mode is enabled\\).\n\nIn the `success` handler of each `read` operation we update the corresponding property in the view model with the real count of the matching items that were returned by the service.\n\n\n\n### webapp/controller/Worklist.controller.js \\[MODIFY\\]\n\n```js\n\t\t...\n\t\t_applySearch: function(aTableSearchState) {\n\t\t\tvar oTable = this.byId(\"table\"),\n\t\t\t\toViewModel = this.getModel(\"worklistView\");\n\t\t\toTable.getBinding(\"items\").filter(aTableSearchState, \"Application\");\n\t\t\t// changes the noDataText of the list in case there are no filter results\n\t\t\tif (aTableSearchState.length !== 0) {\n\t\t\t\toViewModel.setProperty(\"/tableNoDataText\", this.getResourceBundle().getText(\"worklistNoDataWithSearchText\"));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Event handler when a filter tab gets pressed\n\t\t * @param {sap.ui.base.Event} oEvent the filter tab event\n\t\t * @public\n\t\t */\n\t\tonQuickFilter: function(oEvent) {\n\t\t\tvar oBinding = this._oTable.getBinding(\"items\"),\n\t\t\t\tsKey = oEvent.getParameter(\"selectedKey\");\n\t\t\toBinding.filter(this._mFilters[sKey]);\n\t\t}\n\n\n\t});\n\n});\n```\n\nNext, we implement the handler for the `select` event of the `IconTabBar`. In this event handler we get a reference to the binding for the `items` aggregation of our `table` and store it in the variable `oBinding`. Then we read the parameter `selectedKey` from the `event` object to find out which tab has been selected. This `selectedKey` is used to get the correct filter for the selected tab. Next, we simply call the filter method on `oBinding` and pass the correct filter of the selected tab.\n\nThe filters are always applied as an array on the binding level, so you don't need to take care of managing the data, the data binding features of SAPUI5 will automatically take care.\n\n\n\n### webapp/i18n/i18n.properties \\[MODIFY\\]\n\n```ini\n\n...\n\n\n#XTIT: The title of the products quick filter\nWorklistFilterProductsAll=Products\n\n#XTIT: The title of the out of stock products filter\nWorklistFilterOutOfStock=Out of Stock\n\n#XTIT: The title of the low stock products filter\nWorklistFilterShortage=Shortage\n\n#XTIT: The title of the products in stock filter\nWorklistFilterInStock=Plenty in Stock\n\n\n#~~~ Object View ~~~~~~~~~~~~~~~~~~~~~~~~~~\n...\n```\n\nWe finally add the texts for the tab filters to the resource bundle. Copy the text definitions from the code section above to the end of the `Worklistn View` section in the i18n file.\n\nNow run the app again and click the filter icons on top of the table. The products should be filtered according to the selection in the filter bar and the count should match the number of items displayed.\n\n**Related Information**  \n\n\n[API Reference: `sap.ui.model.ListBinding.filter`](https://ui5.sap.com/#/api/sap.ui.model.ListBinding)\n\n",
  "excerpt": "<!-- loio85ec3a9454ac4eb1a901745e773844d3 --> Step 4: Quick Filter for the Worklist For easily detecting and managing product shortages in our app, we will add a quick filter for the worklist table. U...",
  "wordCount": 1424,
  "version": "1.0.0",
  "source": "sapui5",
  "sourceType": "github"
}